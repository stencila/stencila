//! Markdown to Markdown conversion, mostly for internal use

use common::{itertools::Itertools, once_cell::sync::Lazy, regex::Regex};

/// Clean Markdown such as that generated by OCR of PDFs
pub fn clean_md(md: &str) -> String {
    let md = remove_line_numbers(md);
    let md = remove_extra_blank_lines(&md);
    let md = remove_header_formatting(&md);
    let md = ensure_isolated_blocks(&md);
    listify_references(&md)
}

/// Remove line numbers
///
/// PDFs often have line numbering and whilst some OCR will remove those, this
/// is not always successful and some remain.
///
/// This function detects lines with numbers at the start and then assess
/// whether it is likely that these are left over page numbers. If so, it then
/// removes the numbers (is the number is greater than the previous number
/// removed).
fn remove_line_numbers(md: &str) -> String {
    // First, find all lines containing potential line numbers Must be a number
    // followed by whitespace (not a list numbering). Can be after heading
    // hashes.
    static ONLY_NUMBER_REGEX: Lazy<Regex> =
        Lazy::new(|| Regex::new(r"^(\d+)\s*$").expect("invalid regex"));
    static STARTING_NUMBER_REGEX: Lazy<Regex> =
        Lazy::new(|| Regex::new(r"^(#{1,6}\s*)?(\d+)\s+(.*)$").expect("invalid regex"));

    let lines = md
        .lines()
        .map(|line| {
            if let Some(captures) = ONLY_NUMBER_REGEX.captures(line) {
                let number: usize = captures[1].parse().unwrap_or_default();
                Some((number, String::new()))
            } else if let Some(captures) = STARTING_NUMBER_REGEX.captures(line) {
                let hashes = captures
                    .get(1)
                    .map(|hashes| hashes.as_str())
                    .unwrap_or_default();
                let number: usize = captures[2].parse().unwrap_or_default();
                let rest = &captures[3];
                Some((number, [hashes, rest].concat()))
            } else {
                None
            }
        })
        .collect_vec();

    // Assess whether these are likely to be residual lines numbers: at least
    // five of them are monotonic
    let mut run_length = 0;
    let mut last_number = 0;
    for (number, ..) in lines.iter().flatten() {
        if *number > last_number {
            run_length += 1;
            if run_length >= 5 {
                break;
            }
        } else {
            run_length = 0;
        }

        last_number = *number;
    }

    // Remove those that are greater that the previously removed line number
    let mut cleaned_lines = Vec::new();
    let mut last_number = 0;
    for (line, numbered) in md.lines().zip(lines) {
        if let Some((number, rest)) = numbered {
            if number > last_number {
                // Likely a number so only add `rest` and update `last_number`
                cleaned_lines.push(rest);
                last_number = number;
            } else {
                // Otherwise, just add original line
                cleaned_lines.push(line.to_string());
            }
        } else {
            cleaned_lines.push(line.to_string());
        }
    }

    cleaned_lines.join("\n")
}

/// Remove unnecessary blank lines
///
/// OCR can generate multiple successive blank lines, particularly after
/// `remove_line_numbers` is run on the output.
fn remove_extra_blank_lines(md: &str) -> String {
    let lines: Vec<&str> = md.lines().collect();
    let mut result = Vec::new();
    let mut consecutive_blank_lines = 0;

    for line in lines {
        if line.trim().is_empty() {
            consecutive_blank_lines += 1;
            // Only keep one blank line when there are multiple consecutive ones
            if consecutive_blank_lines == 1 {
                result.push(line);
            }
        } else {
            consecutive_blank_lines = 0;
            result.push(line);
        }
    }

    result.join("\n")
}

/// Remove formatting of headers
///
/// OCR can generate a header AND bold (i.e. `**heading**``) or emphasis it
/// (i.e. `_heading_`). This function removes formatting of the entire heading
/// (encompassing all header content) but leaves partial formatting (within
/// heading content).
fn remove_header_formatting(md: &str) -> String {
    // Use separate regexes for each formatting type to ensure balanced markers
    // (e.g., ** must be paired with **, not with __ or *). The regex crate doesn't
    // support backreferences, so we need explicit patterns for each marker type.
    static HEADER_BOLD_DOUBLE_REGEX: Lazy<Regex> =
        Lazy::new(|| Regex::new(r"^(#{1,6})\s*\*\*(.*?)\*\*\s*$").expect("invalid regex"));
    static HEADER_BOLD_UNDERSCORE_REGEX: Lazy<Regex> =
        Lazy::new(|| Regex::new(r"^(#{1,6})\s*__(.*?)__\s*$").expect("invalid regex"));
    static HEADER_EMPHASIS_STAR_REGEX: Lazy<Regex> =
        Lazy::new(|| Regex::new(r"^(#{1,6})\s*\*(.*?)\*\s*$").expect("invalid regex"));
    static HEADER_EMPHASIS_UNDERSCORE_REGEX: Lazy<Regex> =
        Lazy::new(|| Regex::new(r"^(#{1,6})\s*_(.*?)_\s*$").expect("invalid regex"));

    let lines: Vec<&str> = md.lines().collect();
    let mut result = Vec::new();

    for line in lines {
        // Check for headers with bold formatting using **
        if let Some(captures) = HEADER_BOLD_DOUBLE_REGEX.captures(line) {
            let header_level = captures.get(1).expect("header level match").as_str();
            let content = captures.get(2).expect("content match").as_str();
            result.push(format!("{header_level} {content}"));
        }
        // Check for headers with bold formatting using __
        else if let Some(captures) = HEADER_BOLD_UNDERSCORE_REGEX.captures(line) {
            let header_level = captures.get(1).expect("header level match").as_str();
            let content = captures.get(2).expect("content match").as_str();
            result.push(format!("{header_level} {content}"));
        }
        // Check for headers with emphasis formatting using *
        else if let Some(captures) = HEADER_EMPHASIS_STAR_REGEX.captures(line) {
            let header_level = captures.get(1).expect("header level match").as_str();
            let content = captures.get(2).expect("content match").as_str();
            result.push(format!("{header_level} {content}"));
        }
        // Check for headers with emphasis formatting using _
        else if let Some(captures) = HEADER_EMPHASIS_UNDERSCORE_REGEX.captures(line) {
            let header_level = captures.get(1).expect("header level match").as_str();
            let content = captures.get(2).expect("content match").as_str();
            result.push(format!("{header_level} {content}"));
        }
        // Keep line as is
        else {
            result.push(line.to_string());
        }
    }

    result.join("\n")
}

/// Ensure blank lines around heading and block level images
///
/// After running `remove_line_numbers` heading can end up without blank lines
/// before or after.
///
/// OCR can generate a Markdown image on its own line, but not separated from
/// the previous, or next, paragraph. This ensures such images are isolated to
/// that they are treated as figure content.
fn ensure_isolated_blocks(md: &str) -> String {
    static LINE_REGEX: Lazy<Regex> = Lazy::new(|| {
        Regex::new(r"(^\!\[[^\]]*\]\([^\)]*\)\s*$)|(^#{1,6})").expect("invalid regex")
    });

    let lines: Vec<&str> = md.lines().collect();
    let mut result = Vec::new();

    for (index, line) in lines.iter().enumerate() {
        // Check if current line is a heading or image
        if LINE_REGEX.is_match(line) {
            // Add blank line before if previous line exists and is not blank
            if index > 0 {
                let prev_line = lines[index - 1];
                if !prev_line.trim().is_empty() && result.last() != Some(&"") {
                    result.push("");
                }
            }

            // Add the line
            result.push(line);

            // Add blank line after if next line exists and is not blank
            if index + 1 < lines.len() {
                let next_line = lines[index + 1];
                if !next_line.trim().is_empty() {
                    result.push("");
                }
            }
        } else {
            result.push(line);
        }
    }

    result.join("\n")
}

/// Ensure that references are isolated from one another
///
/// OCR can produce references that are neither a numeric list (have a starting
/// number and dot but no blank line between them, which is ok) or a separate
/// paragraphs.
///
/// This function modifies Markdown reference lists where each line starts with
/// a number, or a number surrounded by punctuation, by making them into a
/// numbered list. e.g.
///
/// 1 => 1.
/// 1: => 1.
/// 1) => 1.
/// [1] => 1.
/// (1) => 1.
fn listify_references(md: &str) -> String {
    static HEADING_REGEX: Lazy<Regex> =
        Lazy::new(|| Regex::new(r"^#{1,3}(.*)").expect("invalid regex"));

    static NUMBERED_REGEX: Lazy<Regex> = Lazy::new(|| {
        Regex::new(r"^\s*[\(\[]*\s*(\d+)\s*[\)\]\:\;]*\s*(.*)$").expect("invalid regex")
    });

    let mut result = Vec::new();
    let mut in_references = false;

    for line in md.lines() {
        if let Some(text) = HEADING_REGEX
            .captures(line)
            .and_then(|captures| captures.get(1))
        {
            in_references = matches!(text.as_str().trim(), "References" | "Bibliography");
            result.push(line.to_string());
        } else if !in_references {
            result.push(line.to_string());
        } else if let Some(captures) = NUMBERED_REGEX.captures(line) {
            // Transform the reference format
            let transformed = if captures[2].starts_with(".") {
                captures[0].to_string()
            } else {
                [&captures[1], ". ", &captures[2]].concat()
            };
            result.push(transformed);
        } else {
            // In references section but not a numbered line, keep as is
            result.push(line.to_string());
        }
    }

    result.join("\n")
}

#[cfg(test)]
mod tests {
    use common_dev::insta::assert_snapshot;

    use super::*;

    #[test]
    fn test_remove_line_numbers() {
        // Basic case: consecutive line numbers with monotonic sequence
        let input =
            "1 First line\n2 Second line\n3 Third line\n4 Fourth line\n5 Fifth line\n6 Sixth line";
        assert_snapshot!(remove_line_numbers(input), @" First line\n Second line\n Third line\n Fourth line\n Fifth line\n Sixth line");

        // Line numbers with headers
        let input = "# 1 Header One\n## 2 Header Two\n3 Regular text\n4 More text\n5 Final text";
        assert_snapshot!(remove_line_numbers(input), @r"
        # Header One
        ## Header Two
        Regular text
        More text
        Final text
        ");

        // Mixed content: some lines with numbers, some without
        let input = "1 Numbered line\nNon-numbered line\n2 Another numbered\n3 Yet another\n4 Fourth\n5 Fifth";
        assert_snapshot!(remove_line_numbers(input), @r"
        Numbered line
        Non-numbered line
        Another numbered
        Yet another
        Fourth
        Fifth
        ");

        // Non-monotonic numbers (should detect some patterns)
        let input = "5 Line five\n3 Line three\n7 Line seven\n1 Line one";
        assert_snapshot!(remove_line_numbers(input), @r"
        Line five
        3 Line three
        Line seven
        1 Line one
        ");

        // Insufficient monotonic sequence (less than 5)
        let input = "1 First\n2 Second\n3 Third\n4 Fourth";
        assert_snapshot!(remove_line_numbers(input), @r"
        First
        Second
        Third
        Fourth
        ");

        // Numbers in middle of line (should not be affected)
        let input = "Text with 123 numbers in middle\nAnother line with 456 numbers";
        assert_snapshot!(remove_line_numbers(input), @r"
        Text with 123 numbers in middle
        Another line with 456 numbers
        ");

        // Line numbers with different header levels
        let input = "# 1 Main Header\n## 2 Subheader\n### 3 Sub-subheader\n#### 4 Deep header\n##### 5 Deeper\n###### 6 Deepest";
        assert_snapshot!(remove_line_numbers(input), @r"
        # Main Header
        ## Subheader
        ### Sub-subheader
        #### Deep header
        ##### Deeper
        ###### Deepest
        ");

        // No line numbers
        let input = "Regular text\nMore regular text\nNo numbers here";
        assert_snapshot!(remove_line_numbers(input), @r"
        Regular text
        More regular text
        No numbers here
        ");

        // Line numbers starting from higher number
        let input = "10 Line ten\n11 Line eleven\n12 Line twelve\n13 Line thirteen\n14 Line fourteen\n15 Line fifteen";
        assert_snapshot!(remove_line_numbers(input), @r"
        Line ten
        Line eleven
        Line twelve
        Line thirteen
        Line fourteen
        Line fifteen
        ");

        // Mixed: some monotonic sequences, some not
        let input = "1 First\n2 Second\n3 Third\n4 Fourth\n5 Fifth\n2 Reset\n7 Continue\n8 More\n9 Even more\n10 Last";
        assert_snapshot!(remove_line_numbers(input), @r"
        First
        Second
        Third
        Fourth
        Fifth
        2 Reset
        Continue
        More
        Even more
        Last
        ");

        // Numbered list items should not be changed
        let input = "1. one\n2. two\n3. three\n4. four\n5. five\n6. six";
        assert_eq!(remove_line_numbers(input), input);

        // Just numbers separated by blank lines: should all be removed
        let input = "133\n\n134\n\n135\n\n136\n\n137\n\n138\n\n139\n\n140\n\n141\n\n142";
        assert_snapshot!(remove_line_numbers(input).trim(), @r"");

        // Empty string
        let input = "";
        assert_snapshot!(remove_line_numbers(input), @"");
    }

    #[test]
    fn test_remove_extra_blank_lines() {
        // Multiple consecutive blank lines
        let input = "Line 1\n\n\n\nLine 2";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Line 1
        
        Line 2
        ");

        // Three consecutive blank lines
        let input = "First\n\n\n\nSecond";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        First
        
        Second
        ");

        // Many consecutive blank lines
        let input = "Start\n\n\n\n\n\n\nEnd";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Start
        
        End
        ");

        // Single blank line (should remain unchanged)
        let input = "Text\n\nMore text";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Text
        
        More text
        ");

        // No blank lines (should remain unchanged)
        let input = "Text\nMore text";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Text
        More text
        ");

        // Blank lines at start
        let input = "\n\n\nContent";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        
        Content
        ");

        // Blank lines at end
        let input = "Content\n\n\n";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Content
        
        ");

        // Mixed: multiple blank line groups
        let input = "Para 1\n\n\nPara 2\n\n\n\nPara 3";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Para 1
        
        Para 2
        
        Para 3
        ");

        // Lines with only whitespace
        let input = "Text\n  \n\t\n\nMore";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Text
          
        More
        ");

        // Empty string
        let input = "";
        assert_snapshot!(remove_extra_blank_lines(input), @r"");

        // Only blank lines
        let input = "\n\n\n";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        
        ");

        // Complex document structure
        let input =
            "# Header\n\n\n\nParagraph 1\n\n\nParagraph 2\n\n\n\n## Subheader\n\n\n\nContent";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        # Header
        
        Paragraph 1
        
        Paragraph 2
        
        ## Subheader
        
        Content
        ");
    }

    #[test]
    fn test_ensure_isolated_blocks() {
        // Basic case: image between text
        let input = "Before\n![image.png]()\nAfter";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Before
        
        ![image.png]()
        
        After
        ");

        // Image at start of text
        let input = "![start.png]()\nAfter text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        ![start.png]()
        
        After text
        ");

        // Image at end of text
        let input = "Before text\n![end.png]()";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Before text
        
        ![end.png]()
        
        ");

        // Multiple images
        let input = "Text\n![first.png]()\n![second.png]()\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        ![first.png]()
        
        ![second.png]()
        
        More text
        ");

        // Image already isolated
        let input = "Text\n\n![isolated.png]()\n\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        ![isolated.png]()
        
        More text
        ");

        // Image with alt text and title
        let input = "Text\n![Alt text](image.png 'Title')\nMore";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        ![Alt text](image.png 'Title')
        
        More
        ");

        // Not a block image (inline)
        let input = "This is inline ![small](icon.png) image text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        This is inline ![small](icon.png) image text
        ");

        // Empty lines around image
        let input = "\n\n![image.png]()\n\n";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        
        
        ![image.png]()
        
        
        ");

        // Heading between text
        let input = "Before text\n# Main Heading\nAfter text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Before text
        
        # Main Heading
        
        After text
        ");

        // Multiple headings
        let input = "Text\n# Heading One\n## Heading Two\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        # Heading One
        
        ## Heading Two
        
        More text
        ");

        // Heading at start
        let input = "# Start Heading\nContent follows";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        # Start Heading
        
        Content follows
        ");

        // Heading at end
        let input = "Content before\n## End Heading";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Content before
        
        ## End Heading
        
        ");

        // Heading already isolated
        let input = "Text\n\n### Already Isolated\n\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        ### Already Isolated
        
        More text
        ");

        // Mixed headings and images
        let input = "Text\n# Heading\n![image.png]()\n#### Sub Heading\nFinal text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        # Heading
        
        ![image.png]()
        
        #### Sub Heading
        
        Final text
        ");

        // All heading levels
        let input = "Text\n# H1\n## H2\n### H3\n#### H4\n##### H5\n###### H6\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        # H1
        
        ## H2
        
        ### H3
        
        #### H4
        
        ##### H5
        
        ###### H6
        
        More text
        ");
    }

    #[test]
    fn test_remove_header_formatting() {
        // Header with bold formatting using **
        let input = "# **Bold Header**";
        assert_snapshot!(remove_header_formatting(input), @r"
        # Bold Header
        ");

        // Header with bold formatting using __
        let input = "## __Bold Header Two__";
        assert_snapshot!(remove_header_formatting(input), @r"
        ## Bold Header Two
        ");

        // Header with emphasis formatting using *
        let input = "### *Italic Header*";
        assert_snapshot!(remove_header_formatting(input), @r"
        ### Italic Header
        ");

        // Header with emphasis formatting using _
        let input = "#### _Italic Header Four_";
        assert_snapshot!(remove_header_formatting(input), @r"
        #### Italic Header Four
        ");

        // Multiple levels of headers with formatting
        let input = "# **Main Title**\n## __Subtitle__\n### *Section*\n#### _Subsection_";
        assert_snapshot!(remove_header_formatting(input), @r"
        # Main Title
        ## Subtitle
        ### Section
        #### Subsection
        ");

        // Header with partial formatting (should remain unchanged)
        let input = "# This has **partial** formatting";
        assert_snapshot!(remove_header_formatting(input), @r"
        # This has **partial** formatting
        ");

        // Header with mixed formatting (should remain unchanged)
        let input = "## **Bold** and *italic* text";
        assert_snapshot!(remove_header_formatting(input), @r"
        ## **Bold** and *italic* text
        ");

        // Non-header text with formatting (should remain unchanged)
        let input = "This is **bold** text\nAnd this is *italic*";
        assert_snapshot!(remove_header_formatting(input), @r"
        This is **bold** text
        And this is *italic*
        ");

        // Header with no formatting (should remain unchanged)
        let input = "# Plain Header";
        assert_snapshot!(remove_header_formatting(input), @r"
        # Plain Header
        ");

        // Headers with extra whitespace
        let input = "#  **Header with spaces**  ";
        assert_snapshot!(remove_header_formatting(input), @r"
        # Header with spaces
        ");

        // All header levels with bold formatting
        let input = "# **H1**\n## **H2**\n### **H3**\n#### **H4**\n##### **H5**\n###### **H6**";
        assert_snapshot!(remove_header_formatting(input), @r"
        # H1
        ## H2
        ### H3
        #### H4
        ##### H5
        ###### H6
        ");

        // Empty header with formatting
        let input = "# **  **";
        assert_snapshot!(remove_header_formatting(input), @r"
        #   
        ");

        // Mixed content with headers and regular text
        let input =
            "Some text\n# **Formatted Header**\nMore text\n## __Another Header__\nFinal text";
        assert_snapshot!(remove_header_formatting(input), @r"
        Some text
        # Formatted Header
        More text
        ## Another Header
        Final text
        ");
    }

    #[test]
    fn test_listify_references() {
        // Basic references section
        let input = r"# References

1 First reference here
2 Second reference
3 Third reference";
        assert_snapshot!(listify_references(input), @r"
        # References

        1. First reference here
        2. Second reference
        3. Third reference
        ");

        // References with existing dot format
        let input = r"## References

1. First reference with colon
2. Second reference with colon
3. Third reference with colon";
        assert_snapshot!(listify_references(input), @r"
        ## References

        1. First reference with colon
        2. Second reference with colon
        3. Third reference with colon
        ");

        // References with colon format
        let input = r"## References

1: First reference with colon
2: Second reference with colon
3: Third reference with colon";
        assert_snapshot!(listify_references(input), @r"
        ## References

        1. First reference with colon
        2. Second reference with colon
        3. Third reference with colon
        ");

        // References with parentheses format
        let input = r"### Bibliography

1) First reference with parenthesis
2) Second reference with parenthesis
3) Third reference with parenthesis";
        assert_snapshot!(listify_references(input), @r"
        ### Bibliography

        1. First reference with parenthesis
        2. Second reference with parenthesis
        3. Third reference with parenthesis
        ");

        // References with square brackets
        let input = r"# References

[1] First reference in brackets
[2] Second reference in brackets
[3] Third reference in brackets";
        assert_snapshot!(listify_references(input), @r"
        # References

        1. First reference in brackets
        2. Second reference in brackets
        3. Third reference in brackets
        ");

        // References with round brackets
        let input = r"# Bibliography

(1) First reference in parentheses
(2) Second reference in parentheses
(3) Third reference in parentheses";
        assert_snapshot!(listify_references(input), @r"
        # Bibliography

        1. First reference in parentheses
        2. Second reference in parentheses
        3. Third reference in parentheses
        ");

        // Mixed formats in references
        let input = r"# References

1 First reference
2: Second reference with colon
[3] Third reference in brackets
(4) Fourth reference in parentheses
5) Fifth reference with closing paren";
        assert_snapshot!(listify_references(input), @r"
        # References

        1. First reference
        2. Second reference with colon
        3. Third reference in brackets
        4. Fourth reference in parentheses
        5. Fifth reference with closing paren
        ");

        // Content before references section should not be modified
        let input = r"# Introduction

Some text with 1 number that shouldn't change
Another line with [2] brackets

## References

1 First actual reference
2 Second actual reference";
        assert_snapshot!(listify_references(input), @r"
        # Introduction

        Some text with 1 number that shouldn't change
        Another line with [2] brackets

        ## References
        
        1. First actual reference
        2. Second actual reference
        ");

        // No references section
        let input = r"# Introduction

Some text with 1 number
Another line with [2] brackets
Regular content";
        assert_snapshot!(listify_references(input), @r"
        # Introduction
        
        Some text with 1 number
        Another line with [2] brackets
        Regular content
        ");

        // Multiple sections with only references processed
        let input = r"# Methods

1 This should not change
2 This should not change

# References

1 This should change
2 This should change

# Conclusion

3 This should not change";
        assert_snapshot!(listify_references(input), @r"
        # Methods

        1 This should not change
        2 This should not change

        # References

        1. This should change
        2. This should change

        # Conclusion

        3 This should not change
        ");

        // Empty references section
        let input = r"# References
";
        assert_snapshot!(listify_references(input), @r"
        # References
        ");

        // References with extra whitespace
        let input = r"#   References
   
  1   First reference with spaces
  [2]   Second reference with spaces  
   (3)    Third reference with spaces   ";
        assert_snapshot!(listify_references(input), @r"
        #   References
           
        1. First reference with spaces
        2. Second reference with spaces  
        3. Third reference with spaces
        ");
    }
}
