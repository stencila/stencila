//! Markdown to Markdown conversion, mostly for internal use

use std::sync::LazyLock;

use itertools::Itertools;
use regex::Regex;

/// Clean Markdown such as that generated by OCR of PDFs
pub fn clean_md(md: &str) -> String {
    let md = remove_line_numbers(md);
    let md = remove_extra_blank_lines(&md);
    let md = remove_heading_formatting(&md);
    let md = fix_superscript_subscript(&md);
    let md = remove_unnecessary_inline_math(&md);
    let md = ensure_isolated_blocks(&md);
    ensure_isolated_references(&md)
}

/// Remove line numbers
///
/// PDFs often have line numbering and whilst some OCR will remove those, this
/// is not always successful and some remain.
///
/// This function detects lines with numbers at the start and then assesses
/// whether it is likely that these are left over page numbers. If so, it then
/// removes the numbers (is the number is greater than the previous number
/// removed).
fn remove_line_numbers(md: &str) -> String {
    // First, find all lines containing potential line numbers. Must be a number
    // followed by whitespace (not a list numbering). Can be after heading
    // hashes.
    static ONLY_NUMBER_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"^(\d+)\s*$").expect("invalid regex"));
    static STARTING_NUMBER_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"^(#{1,6}\s*)?(\d+)\s+(.*)$").expect("invalid regex"));

    let lines = md
        .lines()
        .map(|line| {
            if let Some(captures) = ONLY_NUMBER_REGEX.captures(line) {
                let number: usize = captures[1].parse().unwrap_or_default();
                Some((number, String::new()))
            } else if let Some(captures) = STARTING_NUMBER_REGEX.captures(line) {
                let hashes = captures
                    .get(1)
                    .map(|hashes| hashes.as_str())
                    .unwrap_or_default();
                let number: usize = captures[2].parse().unwrap_or_default();
                let rest = &captures[3];
                Some((number, [hashes, rest].concat()))
            } else {
                None
            }
        })
        .collect_vec();

    // Assess whether these are likely to be residual lines numbers: there must be
    // at least one run of at least a minimum length
    const MIN_RUN_LENGTH: u32 = 5;
    let mut are_line_numbers = false;
    let mut run_length = 0;
    let mut last_number = 0;
    for (number, ..) in lines.iter().flatten() {
        if *number > last_number {
            run_length += 1;
            if run_length >= MIN_RUN_LENGTH {
                are_line_numbers = true;
                break;
            }
        } else {
            run_length = 0;
        }

        last_number = *number;
    }

    // Return early with the original content if not deemed to be line numbers
    if !are_line_numbers {
        return md.to_string();
    }

    // Remove those that are greater that the previously removed line number
    let mut cleaned_lines = Vec::new();
    let mut last_number = 0;
    let mut last_number_removed = 0;
    for (line, numbered) in md.lines().zip(lines) {
        if let Some((number, rest)) = numbered {
            if number > last_number_removed && number < (last_number + 1000) {
                // Likely a line number so only add `rest` and update `last_number`
                cleaned_lines.push(rest);
                last_number_removed = number;
            } else {
                // Otherwise, just add original line
                cleaned_lines.push(line.to_string());
            }
            last_number = number;
        } else {
            cleaned_lines.push(line.to_string());
        }
    }

    cleaned_lines.join("\n")
}

/// Remove unnecessary blank lines
///
/// OCR can generate multiple successive blank lines, particularly after
/// `remove_line_numbers` is run on the output.
fn remove_extra_blank_lines(md: &str) -> String {
    let lines: Vec<&str> = md.lines().collect();
    let mut result = Vec::new();
    let mut consecutive_blank_lines = 0;

    for line in lines {
        if line.trim().is_empty() {
            consecutive_blank_lines += 1;
            // Only keep one blank line when there are multiple consecutive ones
            if consecutive_blank_lines == 1 {
                result.push(line);
            }
        } else {
            consecutive_blank_lines = 0;
            result.push(line);
        }
    }

    result.join("\n")
}

/// Remove formatting of headers
///
/// OCR can generate a header AND bold (i.e. `**heading**``) or emphasis it
/// (i.e. `_heading_`). This function removes formatting of the entire heading
/// (encompassing all header content) but leaves partial formatting (within
/// heading content).
fn remove_heading_formatting(md: &str) -> String {
    // Use separate regexes for each formatting type to ensure balanced markers
    // (e.g., ** must be paired with **, not with __ or *). The regex crate doesn't
    // support backreferences, so we need explicit patterns for each marker type.
    static BOLD_DOUBLE_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"^(#{1,6})\s*\*\*(.*?)\*\*\s*$").expect("invalid regex"));
    static BOLD_UNDERSCORE_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"^(#{1,6})\s*__(.*?)__\s*$").expect("invalid regex"));
    static EMPHASIS_STAR_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"^(#{1,6})\s*\*(.*?)\*\s*$").expect("invalid regex"));
    static EMPHASIS_UNDERSCORE_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"^(#{1,6})\s*_(.*?)_\s*$").expect("invalid regex"));

    let lines: Vec<&str> = md.lines().collect();
    let mut result = Vec::new();

    for line in lines {
        // Check for headers with bold formatting using **
        if let Some(captures) = BOLD_DOUBLE_REGEX.captures(line) {
            let header_level = captures.get(1).expect("header level match").as_str();
            let content = captures.get(2).expect("content match").as_str();
            result.push(format!("{header_level} {content}"));
        }
        // Check for headers with bold formatting using __
        else if let Some(captures) = BOLD_UNDERSCORE_REGEX.captures(line) {
            let header_level = captures.get(1).expect("header level match").as_str();
            let content = captures.get(2).expect("content match").as_str();
            result.push(format!("{header_level} {content}"));
        }
        // Check for headers with emphasis formatting using *
        else if let Some(captures) = EMPHASIS_STAR_REGEX.captures(line) {
            let header_level = captures.get(1).expect("header level match").as_str();
            let content = captures.get(2).expect("content match").as_str();
            result.push(format!("{header_level} {content}"));
        }
        // Check for headers with emphasis formatting using _
        else if let Some(captures) = EMPHASIS_UNDERSCORE_REGEX.captures(line) {
            let header_level = captures.get(1).expect("header level match").as_str();
            let content = captures.get(2).expect("content match").as_str();
            result.push(format!("{header_level} {content}"));
        }
        // Keep line as is
        else {
            result.push(line.to_string());
        }
    }

    result.join("\n")
}

/// Remove unnecessary inline math (delimited by single dollars)
///
/// Some OCR (e.g. Mistral) can be over enthusiastic with creating inline TeX
/// math. Often TeX is used when ASCII or Unicode would suffice e.g.
///
/// $\$ 40$                         =>      $ 40
/// $(\sim 100 \mathrm{nL})$        =>      (~ 100nL)
/// $0.022 \pm 0.0005 \mathrm{g}$   =>      0.022 ± 0.0005 g
///
/// The first example is problematic because our Markdown parse does not escape
/// dollars inside math and so we end up with unbalanced dollars which breaks
/// parsing. The other examples above do not cause such issues but are
/// unnecessary.
fn remove_unnecessary_inline_math(md: &str) -> String {
    static INLINE_MATH_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"\$([^$]*?(?:\\.[^$]*?)*)\$").expect("invalid regex"));

    INLINE_MATH_REGEX
        .replace_all(md, |caps: &regex::Captures| {
            let math_content = &caps[1];
            let simplified = simplify_tex(math_content);

            // If the math content is empty or the simplified version contains no TeX commands,
            // and the simplified version is not empty, remove the dollar delimiters
            if !simplified.trim().is_empty() && !contains_tex_commands(&simplified) {
                simplified
            } else {
                // Keep the original math expression
                format!("${}$", math_content)
            }
        })
        .to_string()
}

/// Fix invalid superscript and subscript syntax from OCR
///
/// OCR can generate LaTeX-style superscript `^{content}` and subscript `_{content}`
/// syntax instead of Pandoc's Markdown syntax. This function converts them:
///
/// - `text^{sup}` -> `text^sup^`
/// - `text_{sub}` -> `text~sub~`
///
/// Does not perform replacements inside math mode (delimited by `$...$` or `$$...$$`).
fn fix_superscript_subscript(md: &str) -> String {
    let mut result = String::with_capacity(md.len());
    let mut chars = md.chars().peekable();
    let mut in_math = false;

    while let Some(ch) = chars.next() {
        if ch == '\\' {
            // Handle escape sequences - preserve backslash and next char
            result.push(ch);
            if let Some(next_ch) = chars.next() {
                result.push(next_ch);
                // If it's an escaped dollar, don't toggle math mode
            }
        } else if ch == '$' {
            result.push(ch);
            // Check for $$ (display math) - consume both as one delimiter
            if let Some(&'$') = chars.peek() {
                result.push(chars.next().expect("peeked above"));
            }
            // Toggle math mode
            in_math = !in_math;
        } else if !in_math && (ch == '^' || ch == '_') {
            let marker = ch; // Save the original marker
            // Check if followed by {
            if let Some(&'{') = chars.peek() {
                chars.next(); // consume the {

                // Collect content until matching }
                let mut content = String::new();
                let mut brace_count = 1;

                for ch in chars.by_ref() {
                    if ch == '{' {
                        brace_count += 1;
                        content.push(ch);
                    } else if ch == '}' {
                        brace_count -= 1;
                        if brace_count == 0 {
                            break;
                        }
                        content.push(ch);
                    } else {
                        content.push(ch);
                    }
                }

                // Replace based on the original marker
                if marker == '^' {
                    result.push('^');
                    result.push_str(&content);
                    result.push('^');
                } else {
                    result.push('~');
                    result.push_str(&content);
                    result.push('~');
                }
            } else {
                result.push(ch);
            }
        } else {
            result.push(ch);
        }
    }

    result
}

/// Simplify common TeX commands to Unicode/ASCII equivalents
fn simplify_tex(tex: &str) -> String {
    use std::collections::HashMap;

    static REPLACEMENTS: LazyLock<HashMap<&str, &str>> = LazyLock::new(|| {
        HashMap::from([
            // Common symbol replacements
            ("\\$", "$"),      // Escaped dollar
            (r"\sim", "~"),    // Tilde
            (r"\pm", "±"),     // Plus-minus
            (r"\times", "×"),  // Multiplication
            (r"\approx", "≈"), // Approximately
            (r"\leq", "≤"),    // Less than or equal
            (r"\geq", "≥"),    // Greater than or equal
            (r"\neq", "≠"),    // Not equal
            (r"\infty", "∞"),  // Infinity
            ("~", " "),        // Non-breaking space to regular space
            // Greek letters (common ones)
            (r"\alpha", "α"),
            (r"\beta", "β"),
            (r"\gamma", "γ"),
            (r"\delta", "δ"),
            (r"\epsilon", "ε"),
            (r"\mu", "μ"),
            (r"\pi", "π"),
            (r"\sigma", "σ"),
            (r"\theta", "θ"),
            (r"\lambda", "λ"),
            (r"\omega", "ω"),
        ])
    });

    let mut result = String::with_capacity(tex.len()); // Pre-allocate reasonable size
    let mut chars = tex.chars().peekable();

    while let Some(ch) = chars.next() {
        // Check for simple single-character replacements first
        if let Some(&replacement) = REPLACEMENTS.get(&ch.to_string().as_str()) {
            result.push_str(replacement);
        } else if ch == '\\' {
            // Found a backslash, try to parse TeX command
            let mut command = String::from("\\");

            // Special case: handle \$ (escaped dollar)
            if let Some(&next_ch) = chars.peek() {
                if next_ch == '$' {
                    command.push(chars.next().expect("peeked above"));
                } else {
                    // Collect the command name (letters after backslash)
                    while let Some(&next_ch) = chars.peek() {
                        if next_ch.is_ascii_alphabetic() {
                            command.push(chars.next().expect("peeked above"));
                        } else {
                            break;
                        }
                    }
                }
            }

            // Check if this is a brace-based command (\mathrm{...}, \mathit{...}, \mathbf{...})
            if matches!(command.as_str(), r"\mathrm" | r"\mathit" | r"\mathbf") {
                // Check if followed by {
                if let Some(&'{') = chars.peek() {
                    chars.next(); // consume the {
                    let mut brace_content = String::new();
                    let mut brace_count = 1;

                    // Parse until matching }
                    for ch in chars.by_ref() {
                        if ch == '{' {
                            brace_count += 1;
                            brace_content.push(ch);
                        } else if ch == '}' {
                            brace_count -= 1;
                            if brace_count == 0 {
                                break; // Found matching closing brace
                            }
                            brace_content.push(ch);
                        } else {
                            brace_content.push(ch);
                        }
                    }

                    // For \mathrm{...}, \mathit{...}, \mathbf{...}, apply simple character replacements to the content
                    for ch in brace_content.chars() {
                        if let Some(&replacement) = REPLACEMENTS.get(&ch.to_string().as_str()) {
                            // If replacement is whitespace, apply space normalization
                            if replacement.trim().is_empty() {
                                if !result.chars().last().is_some_and(|c| c.is_whitespace()) {
                                    result.push(' ');
                                }
                            } else {
                                result.push_str(replacement);
                            }
                        } else if ch.is_whitespace() {
                            // Handle space normalization for brace content too
                            if !result.chars().last().is_some_and(|c| c.is_whitespace()) {
                                result.push(' ');
                            }
                        } else {
                            result.push(ch);
                        }
                    }
                } else {
                    // No brace found, keep the original command
                    result.push_str(&command);
                }
            }
            // Check if we have a simple replacement for this command
            else if let Some(&replacement) = REPLACEMENTS.get(command.as_str()) {
                result.push_str(replacement);
            } else {
                // No replacement found, keep the original command
                result.push_str(&command);
            }
        } else {
            // Handle space normalization during parsing
            if ch.is_whitespace() {
                // Add a single space if the last character wasn't whitespace
                if !result.chars().last().is_some_and(|c| c.is_whitespace()) {
                    result.push(' ');
                }
            } else {
                result.push(ch);
            }
        }
    }

    // Final trim to remove leading/trailing whitespace
    result.trim().to_string()
}

/// Check if a string contains TeX commands or mathematical constructs that
/// should remain in math mode
fn contains_tex_commands(s: &str) -> bool {
    let mut chars = s.chars();

    while let Some(ch) = chars.next() {
        match ch {
            // TeX-specific characters
            '{' | '}' | '^' | '_' => return true,

            // Mathematical operators - if present, keep as math to be safe
            '=' | '+' | '-' | '*' | '/' => return true,

            // TeX commands (\command)
            '\\' => {
                // Check if followed by an alphabetic character
                if chars
                    .as_str()
                    .chars()
                    .next()
                    .is_some_and(|c| c.is_ascii_alphabetic())
                {
                    return true;
                }
            }

            _ => {} // Continue for other characters
        }
    }

    false
}

/// Ensure blank lines around headings, block level images, and table/figure captions
///
/// After running `remove_line_numbers` heading can end up without blank lines
/// before or after.
///
/// OCR can generate a Markdown image on its own line, but not separated from
/// the previous, or next, paragraph. This ensures such images are isolated so
/// that they are treated as figure content.
///
/// Similarly, detects lines that look like table or figure captions (starting with "Table X"
/// or "Figure X") and ensures there is a blank line before and after them. This helps with
/// proper caption recognition during document structuring.
fn ensure_isolated_blocks(md: &str) -> String {
    static LINE_REGEX: LazyLock<Regex> = LazyLock::new(|| {
        Regex::new(r"(^\!\[[^\]]*\]\([^\)]*\)\s*$)|(^#{1,6})|(^(?i)(?:Table|Figure|Fig\.?)\s*\d+[.:\-\s]*)").expect("invalid regex")
    });

    let lines: Vec<&str> = md.lines().collect();
    let mut result = Vec::new();

    for (index, line) in lines.iter().enumerate() {
        // Check if current line is a heading, image, or table/figure caption
        if LINE_REGEX.is_match(line) {
            // Add blank line before if previous line exists and is not blank
            if index > 0 {
                let prev_line = lines[index - 1];
                if !prev_line.trim().is_empty() && result.last() != Some(&"") {
                    result.push("");
                }
            }

            // Add the line
            result.push(line);

            // Add blank line after if next line exists and is not blank
            if index + 1 < lines.len() {
                let next_line = lines[index + 1];
                if !next_line.trim().is_empty() {
                    result.push("");
                }
            }
        } else {
            result.push(line);
        }
    }

    result.join("\n")
}

/// Ensure that references are isolated from one another
///
/// OCR can produce references that are neither a numeric list (have a starting
/// number and dot but no blank line between them, which is ok) or a separate
/// paragraphs.
fn ensure_isolated_references(md: &str) -> String {
    // Regex to detect a heading for the references section
    static REFERENCES_REGEX: LazyLock<Regex> = LazyLock::new(|| {
        Regex::new(r"(?i)^#{1,4}\s*(?:\d+\.?\s*|[a-z]\.?\s*|[ivx]+\.?\s*)?(references?|bibliography|works?\s+cited|literature\s+cited|citations?|sources?|reference\s+list|further\s+reading|additional\s+sources|for\s+further\s+information)\s*$").expect("invalid regex")
    });

    // Regex to detect a heading after the references section
    static HEADING_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"^#{1,4}").expect("invalid regex"));

    // Regex to ensure numbered lines are numbered list items
    // 1 => 1.
    // 1. => 1.
    // 1) => 1.
    // [1] => 1.
    // (1) => 1.
    static NUMBERED_REGEX: LazyLock<Regex> = LazyLock::new(|| {
        Regex::new(r"^\s*[\(\[]*\s*(\d+)\s*[\)\]\.]*\s*(.*)$").expect("invalid regex")
    });

    // Regex to detect whether a line appears to be the start of a reference
    // based on having a punctuated year e.g. "(1981)" "2021."
    static YEAR_REGEX: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"(\((19|20)\d\d\))|((19|20)\d\d.)").expect("invalid regex"));

    fn replace_chars(line: &str) -> String {
        // Replace ■ with endash
        // Sometimes PDF will contain "unknown
        // character" symbols (question mark in a box). In references section, often
        // these appear to be in the place where a page range endash was intended
        line.replace('■', "–")
    }

    let mut result = Vec::new();
    let mut in_references = false;
    let mut last_reference_number = 0u32;
    for line in md.lines() {
        if !in_references && REFERENCES_REGEX.is_match(line) {
            // Entering references section
            in_references = true;
            result.push(line.to_string());
        } else if in_references && HEADING_REGEX.is_match(line) {
            // Exiting references section
            in_references = false;
            result.push(line.to_string());
        } else if !in_references {
            // Not in references so keep line as is
            result.push(line.to_string());
        } else if let Some(captures) = NUMBERED_REGEX.captures(line) {
            // In references section and line is numbered
            let reference_number: u32 = captures[1].parse().expect("is only digits");
            let rest = &captures[2];

            // If the number is lower than, or a big jump up from, the last
            // number it id likely some part of the reference that happens to be a number
            // followed by punctuation at the start of the line e.g "2006." so just indent
            // it by two spaces.
            let transformed = if reference_number > last_reference_number
                && reference_number < last_reference_number + 5
            {
                last_reference_number = reference_number;
                format!("{reference_number}. {rest}")
            } else {
                format!("    {line}")
            };

            result.push(replace_chars(&transformed));
        } else if YEAR_REGEX.is_match(line) && last_reference_number == 0 {
            // In references section, not in a numbered reference list, but appears to be a reference
            // so ensure a blank line before it
            if let Some(last) = result.last()
                && !last.trim().is_empty()
            {
                result.push(String::new())
            }
            result.push(replace_chars(line));
        } else {
            // In references section but line is not numbered or has punctuated year in it
            result.push(replace_chars(line));
        }
    }

    result.join("\n")
}

#[cfg(test)]
mod tests {
    use insta::assert_snapshot;

    use super::*;

    #[test]
    fn test_remove_line_numbers() {
        // Basic case: consecutive line numbers with monotonic sequence
        let input =
            "1 First line\n2 Second line\n3 Third line\n4 Fourth line\n5 Fifth line\n6 Sixth line";
        assert_snapshot!(remove_line_numbers(input), @" First line\n Second line\n Third line\n Fourth line\n Fifth line\n Sixth line");

        // Line numbers with headers
        let input = "# 1 Header One\n## 2 Header Two\n3 Regular text\n4 More text\n5 Final text";
        assert_snapshot!(remove_line_numbers(input), @r"
        # Header One
        ## Header Two
        Regular text
        More text
        Final text
        ");

        // Mixed content: some lines with numbers, some without
        let input = "1 Numbered line\nNon-numbered line\n2 Another numbered\n3 Yet another\n4 Fourth\n5 Fifth";
        assert_snapshot!(remove_line_numbers(input), @r"
        Numbered line
        Non-numbered line
        Another numbered
        Yet another
        Fourth
        Fifth
        ");

        // Non-monotonic numbers (should detect some patterns)
        let input = "5 Line five\n3 Line three\n7 Line seven\n1 Line one";
        assert_snapshot!(remove_line_numbers(input), @r"
        5 Line five
        3 Line three
        7 Line seven
        1 Line one
        ");

        // Insufficient monotonic sequence (less than 5)
        let input = "1 First\n2 Second\n3 Third\n4 Fourth";
        assert_snapshot!(remove_line_numbers(input), @r"
        1 First
        2 Second
        3 Third
        4 Fourth
        ");

        // Numbers in middle of line (should not be affected)
        let input = "Text with 123 numbers in middle\nAnother line with 456 numbers";
        assert_snapshot!(remove_line_numbers(input), @r"
        Text with 123 numbers in middle
        Another line with 456 numbers
        ");

        // Line numbers with different header levels
        let input = "# 1 Main Header\n## 2 Subheader\n### 3 Sub-subheader\n#### 4 Deep header\n##### 5 Deeper\n###### 6 Deepest";
        assert_snapshot!(remove_line_numbers(input), @r"
        # Main Header
        ## Subheader
        ### Sub-subheader
        #### Deep header
        ##### Deeper
        ###### Deepest
        ");

        // No line numbers
        let input = "Regular text\nMore regular text\nNo numbers here";
        assert_snapshot!(remove_line_numbers(input), @r"
        Regular text
        More regular text
        No numbers here
        ");

        // Line numbers starting from higher number
        let input = "10 Line ten\n11 Line eleven\n12 Line twelve\n13 Line thirteen\n14 Line fourteen\n15 Line fifteen";
        assert_snapshot!(remove_line_numbers(input), @r"
        Line ten
        Line eleven
        Line twelve
        Line thirteen
        Line fourteen
        Line fifteen
        ");

        // Mixed: some monotonic sequences, some not
        let input = "1 First\n2 Second\n3 Third\n4 Fourth\n5 Fifth\n2 Reset\n7 Continue\n8 More\n9 Even more\n10 Last";
        assert_snapshot!(remove_line_numbers(input), @r"
        First
        Second
        Third
        Fourth
        Fifth
        2 Reset
        Continue
        More
        Even more
        Last
        ");

        // Numbered list items should not be changed
        let input = "1. one\n2. two\n3. three\n4. four\n5. five\n6. six";
        assert_eq!(remove_line_numbers(input), input);

        // Just numbers separated by blank lines: should all be removed
        let input = "133\n\n134\n\n135\n\n136\n\n137\n\n138\n\n139\n\n140\n\n141\n\n142";
        assert_snapshot!(remove_line_numbers(input).trim(), @r"");

        // Empty string
        let input = "";
        assert_snapshot!(remove_line_numbers(input), @"");
    }

    #[test]
    fn test_remove_extra_blank_lines() {
        // Multiple consecutive blank lines
        let input = "Line 1\n\n\n\nLine 2";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Line 1
        
        Line 2
        ");

        // Three consecutive blank lines
        let input = "First\n\n\n\nSecond";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        First
        
        Second
        ");

        // Many consecutive blank lines
        let input = "Start\n\n\n\n\n\n\nEnd";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Start
        
        End
        ");

        // Single blank line (should remain unchanged)
        let input = "Text\n\nMore text";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Text
        
        More text
        ");

        // No blank lines (should remain unchanged)
        let input = "Text\nMore text";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Text
        More text
        ");

        // Blank lines at start
        let input = "\n\n\nContent";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        
        Content
        ");

        // Blank lines at end
        let input = "Content\n\n\n";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Content
        
        ");

        // Mixed: multiple blank line groups
        let input = "Para 1\n\n\nPara 2\n\n\n\nPara 3";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Para 1
        
        Para 2
        
        Para 3
        ");

        // Lines with only whitespace
        let input = "Text\n  \n\t\n\nMore";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        Text
          
        More
        ");

        // Empty string
        let input = "";
        assert_snapshot!(remove_extra_blank_lines(input), @r"");

        // Only blank lines
        let input = "\n\n\n";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        
        ");

        // Complex document structure
        let input =
            "# Header\n\n\n\nParagraph 1\n\n\nParagraph 2\n\n\n\n## Subheader\n\n\n\nContent";
        assert_snapshot!(remove_extra_blank_lines(input), @r"
        # Header
        
        Paragraph 1
        
        Paragraph 2
        
        ## Subheader
        
        Content
        ");
    }

    #[test]
    fn test_ensure_isolated_blocks() {
        // Basic case: image between text
        let input = "Before\n![image.png]()\nAfter";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Before
        
        ![image.png]()
        
        After
        ");

        // Image at start of text
        let input = "![start.png]()\nAfter text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        ![start.png]()
        
        After text
        ");

        // Image at end of text
        let input = "Before text\n![end.png]()";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Before text
        
        ![end.png]()
        
        ");

        // Multiple images
        let input = "Text\n![first.png]()\n![second.png]()\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        ![first.png]()
        
        ![second.png]()
        
        More text
        ");

        // Image already isolated
        let input = "Text\n\n![isolated.png]()\n\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        ![isolated.png]()
        
        More text
        ");

        // Image with alt text and title
        let input = "Text\n![Alt text](image.png 'Title')\nMore";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        ![Alt text](image.png 'Title')
        
        More
        ");

        // Not a block image (inline)
        let input = "This is inline ![small](icon.png) image text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        This is inline ![small](icon.png) image text
        ");

        // Empty lines around image
        let input = "\n\n![image.png]()\n\n";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        
        
        ![image.png]()
        
        
        ");

        // Heading between text
        let input = "Before text\n# Main Heading\nAfter text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Before text
        
        # Main Heading
        
        After text
        ");

        // Multiple headings
        let input = "Text\n# Heading One\n## Heading Two\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        # Heading One
        
        ## Heading Two
        
        More text
        ");

        // Heading at start
        let input = "# Start Heading\nContent follows";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        # Start Heading
        
        Content follows
        ");

        // Heading at end
        let input = "Content before\n## End Heading";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Content before
        
        ## End Heading
        
        ");

        // Heading already isolated
        let input = "Text\n\n### Already Isolated\n\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        ### Already Isolated
        
        More text
        ");

        // Mixed headings and images
        let input = "Text\n# Heading\n![image.png]()\n#### Sub Heading\nFinal text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        # Heading
        
        ![image.png]()
        
        #### Sub Heading
        
        Final text
        ");

        // All heading levels
        let input = "Text\n# H1\n## H2\n### H3\n#### H4\n##### H5\n###### H6\nMore text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text
        
        # H1
        
        ## H2
        
        ### H3
        
        #### H4
        
        ##### H5
        
        ###### H6
        
        More text
        ");

        // Table caption isolation
        let input = "Before text\nTable 1. This is a table caption\nAfter text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Before text

        Table 1. This is a table caption

        After text
        ");

        // Figure caption isolation
        let input = "Before text\nFigure 2: This is a figure caption\nAfter text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Before text

        Figure 2: This is a figure caption

        After text
        ");

        // Mixed content: headings, images, and captions
        let input = "Text\n# Heading\n![image.png]()\nTable 1. Data overview\n#### Sub Heading\nFigure 1: Visual\nFinal text";
        assert_snapshot!(ensure_isolated_blocks(input), @r"
        Text

        # Heading

        ![image.png]()

        Table 1. Data overview

        #### Sub Heading

        Figure 1: Visual

        Final text
        ");
    }

    #[test]
    fn test_remove_header_formatting() {
        // Header with bold formatting using **
        let input = "# **Bold Header**";
        assert_snapshot!(remove_heading_formatting(input), @r"
        # Bold Header
        ");

        // Header with bold formatting using __
        let input = "## __Bold Header Two__";
        assert_snapshot!(remove_heading_formatting(input), @r"
        ## Bold Header Two
        ");

        // Header with emphasis formatting using *
        let input = "### *Italic Header*";
        assert_snapshot!(remove_heading_formatting(input), @r"
        ### Italic Header
        ");

        // Header with emphasis formatting using _
        let input = "#### _Italic Header Four_";
        assert_snapshot!(remove_heading_formatting(input), @r"
        #### Italic Header Four
        ");

        // Multiple levels of headers with formatting
        let input = "# **Main Title**\n## __Subtitle__\n### *Section*\n#### _Subsection_";
        assert_snapshot!(remove_heading_formatting(input), @r"
        # Main Title
        ## Subtitle
        ### Section
        #### Subsection
        ");

        // Header with partial formatting (should remain unchanged)
        let input = "# This has **partial** formatting";
        assert_snapshot!(remove_heading_formatting(input), @r"
        # This has **partial** formatting
        ");

        // Header with mixed formatting (should remain unchanged)
        let input = "## **Bold** and *italic* text";
        assert_snapshot!(remove_heading_formatting(input), @r"
        ## **Bold** and *italic* text
        ");

        // Non-header text with formatting (should remain unchanged)
        let input = "This is **bold** text\nAnd this is *italic*";
        assert_snapshot!(remove_heading_formatting(input), @r"
        This is **bold** text
        And this is *italic*
        ");

        // Header with no formatting (should remain unchanged)
        let input = "# Plain Header";
        assert_snapshot!(remove_heading_formatting(input), @r"
        # Plain Header
        ");

        // Headers with extra whitespace
        let input = "#  **Header with spaces**  ";
        assert_snapshot!(remove_heading_formatting(input), @r"
        # Header with spaces
        ");

        // All header levels with bold formatting
        let input = "# **H1**\n## **H2**\n### **H3**\n#### **H4**\n##### **H5**\n###### **H6**";
        assert_snapshot!(remove_heading_formatting(input), @r"
        # H1
        ## H2
        ### H3
        #### H4
        ##### H5
        ###### H6
        ");

        // Empty header with formatting
        let input = "# **  **";
        assert_snapshot!(remove_heading_formatting(input), @r"
        #   
        ");

        // Mixed content with headers and regular text
        let input =
            "Some text\n# **Formatted Header**\nMore text\n## __Another Header__\nFinal text";
        assert_snapshot!(remove_heading_formatting(input), @r"
        Some text
        # Formatted Header
        More text
        ## Another Header
        Final text
        ");
    }

    #[test]
    fn test_remove_unnecessary_inline_math() {
        // Test the examples from the documentation comments

        // Debug: test basic replacement first
        let input = r"Simple: $\alpha$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Simple: α");

        // Escaped dollar sign - problematic case that should be simplified
        let input = r"The cost is $\$ 40$ for this item";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"The cost is $ 40 for this item");

        // Tilde with mathrm unit
        let input = r"The volume is $(\sim 100 \mathrm{nL})$ approximately";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"The volume is (~ 100 nL) approximately");

        // Plus-minus with mathrm unit
        let input = r"Mass: $0.022 \pm 0.0005 \mathrm{g}$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Mass: 0.022 ± 0.0005 g");

        // Test common symbols that can be simplified
        let input = r"Temperature $\approx 25°C$ and pressure $\leq 1 \mathrm{atm}$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Temperature ≈ 25°C and pressure ≤ 1 atm");

        // Test Greek letters
        let input = r"The angle $\theta$ and constant $\pi$ are important";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"The angle θ and constant π are important");

        // Test multiplication and other symbols
        let input = r"Result: $5 \times 10$ and $x \neq 0$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Result: 5 × 10 and x ≠ 0");

        // Test complex TeX that should NOT be simplified (contains complex commands)
        let input = r"Complex formula: $\frac{1}{2}\sqrt{x^2 + y^2}$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Complex formula: $\frac{1}{2}\sqrt{x^2 + y^2}$");

        // Test mixed content - some can be simplified, some cannot
        let input = r"Simple: $\alpha$ but complex: $\int_0^\infty x dx$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Simple: α but complex: $\int_0^\infty x dx$");

        // Test multiple mathrm expressions
        let input = r"Units: $\mathrm{kg}$, $\mathrm{m}$, $\mathrm{s}$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Units: kg, m, s");

        // Test mathit and mathbf
        let input = r"Variables: $\mathit{velocity}$ and $\mathbf{force}$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Variables: velocity and force");

        // Test expressions with superscripts/subscripts should not be simplified
        let input = r"Formula: $E = mc^2$ and $H_2O$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Formula: $E = mc^2$ and $H_2O$");

        // Test expressions with braces that aren't math commands should not be simplified
        let input = r"Set notation: $\{1, 2, 3\}$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Set notation: $\{1, 2, 3\}$");

        // Test empty math expression
        let input = r"Empty math: $$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Empty math: $$");

        // Test no math expressions
        let input = r"Regular text with no math expressions";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Regular text with no math expressions");

        // Test multiple math expressions in one line
        let input = r"Multiple: $\alpha$ and $\beta$ and $\gamma$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Multiple: α and β and γ");

        // Test edge case with dollar signs in regular text (should not be affected)
        let input = r"The price is 5 dollars, not $x + y = z$.";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"The price is 5 dollars, not $x + y = z$.");

        // Test math with spaces
        let input = r"Spaced math: $\alpha   \beta$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Spaced math: α β");

        // Test infinity symbol
        let input = r"Limit: $x \to \infty$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Limit: $x \to \infty$"); // Should not simplify due to \to

        // Test just infinity
        let input = r"Infinity: $\infty$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Infinity: ∞");

        // Test tilde (non-breaking space) replacement
        let input = r"Units: $8.31 \pm 0.039 \mathrm{~mm}$";
        assert_snapshot!(remove_unnecessary_inline_math(input), @r"Units: 8.31 ± 0.039 mm");
    }

    #[test]
    fn test_listify_references() {
        // Basic references section
        let input = r"# References

1 First reference here
2 Second reference
3 Third reference";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # References

        1. First reference here
        2. Second reference
        3. Third reference
        ");

        // References with existing dot format
        let input = r"## References

1. First reference with colon
2. Second reference with colon
3. Third reference with colon";
        assert_snapshot!(ensure_isolated_references(input), @r"
        ## References

        1. First reference with colon
        2. Second reference with colon
        3. Third reference with colon
        ");

        // References with parentheses format
        let input = r"### Bibliography

1) First reference with parenthesis
2) Second reference with parenthesis
3) Third reference with parenthesis";
        assert_snapshot!(ensure_isolated_references(input), @r"
        ### Bibliography

        1. First reference with parenthesis
        2. Second reference with parenthesis
        3. Third reference with parenthesis
        ");

        // References with square brackets
        let input = r"# References

[1] First reference in brackets
[2] Second reference in brackets
[3] Third reference in brackets";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # References

        1. First reference in brackets
        2. Second reference in brackets
        3. Third reference in brackets
        ");

        // References with round brackets
        let input = r"# Bibliography

(1) First reference in parentheses
(2) Second reference in parentheses
(3) Third reference in parentheses";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # Bibliography

        1. First reference in parentheses
        2. Second reference in parentheses
        3. Third reference in parentheses
        ");

        // Mixed formats in references
        let input = r"# References

1 First reference
2. Second reference with dot
[3] Third reference in brackets
(4) Fourth reference in parentheses
5) Fifth reference with closing paren";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # References

        1. First reference
        2. Second reference with dot
        3. Third reference in brackets
        4. Fourth reference in parentheses
        5. Fifth reference with closing paren
        ");

        // Content before references section should not be modified
        let input = r"# Introduction

Some text with 1 number that shouldn't change
Another line with [2] brackets

## References

1 First actual reference
2 Second actual reference";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # Introduction

        Some text with 1 number that shouldn't change
        Another line with [2] brackets

        ## References
        
        1. First actual reference
        2. Second actual reference
        ");

        // No references section
        let input = r"# Introduction

Some text with 1 number
Another line with [2] brackets
Regular content";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # Introduction
        
        Some text with 1 number
        Another line with [2] brackets
        Regular content
        ");

        // Multiple sections with only references processed
        let input = r"# Methods

1 This should not change
2 This should not change

# References

1 This should change
2 This should change

# Conclusion

3 This should not change";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # Methods

        1 This should not change
        2 This should not change

        # References

        1. This should change
        2. This should change

        # Conclusion

        3 This should not change
        ");

        // Empty references section
        let input = r"# References
";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # References
        ");

        // References with extra whitespace
        let input = r"#   References
   
  1   First reference with spaces
  [2]   Second reference with spaces  
   (3)    Third reference with spaces   ";
        assert_snapshot!(ensure_isolated_references(input), @r"
        #   References
           
        1. First reference with spaces
        2. Second reference with spaces  
        3. Third reference with spaces
        ");

        // References with non-sequential numbers (should be indented)
        let input = r"# References

1 First reference
2 Second reference  
2006. This looks like a year and should be indented
3 Third reference
10 Large jump should be indented
4 Fourth reference continues sequence";
        assert_snapshot!(ensure_isolated_references(input), @r"
        # References

        1. First reference
        2. Second reference  
            2006. This looks like a year and should be indented
        3. Third reference
            10 Large jump should be indented
        4. Fourth reference continues sequence
        ");
    }

    #[test]
    fn test_fix_superscript_subscript() {
        // Basic superscript replacement
        let input = r"x^{2}";
        assert_snapshot!(fix_superscript_subscript(input), @r"x^2^");

        // Basic subscript replacement
        let input = r"H_{2}O";
        assert_snapshot!(fix_superscript_subscript(input), @r"H~2~O");

        // Multiple superscripts in one line
        let input = r"x^{2} + y^{3}";
        assert_snapshot!(fix_superscript_subscript(input), @r"x^2^ + y^3^");

        // Multiple subscripts in one line
        let input = r"a_{i} and b_{j}";
        assert_snapshot!(fix_superscript_subscript(input), @r"a~i~ and b~j~");

        // Mixed superscripts and subscripts
        let input = r"x^{2} and H_{2}O";
        assert_snapshot!(fix_superscript_subscript(input), @r"x^2^ and H~2~O");

        // Superscript at start of line
        let input = r"^{sup}text";
        assert_snapshot!(fix_superscript_subscript(input), @r"^sup^text");

        // Subscript at end of line
        let input = r"text_{sub}";
        assert_snapshot!(fix_superscript_subscript(input), @r"text~sub~");

        // Multi-character content
        let input = r"text^{superscript} and text_{subscript}";
        assert_snapshot!(fix_superscript_subscript(input), @r"text^superscript^ and text~subscript~");

        // Math mode protection - inline math with superscript should stay
        let input = r"$x^{2}$";
        assert_snapshot!(fix_superscript_subscript(input), @r"$x^{2}$");

        // Math mode protection - inline math with subscript should stay
        let input = r"$H_{2}O$";
        assert_snapshot!(fix_superscript_subscript(input), @r"$H_{2}O$");

        // Math mode protection - display math
        let input = r"$$x^{2} + y^{2}$$";
        assert_snapshot!(fix_superscript_subscript(input), @r"$$x^{2} + y^{2}$$");

        // Mixed: text with replacements and math mode
        let input = r"x^{2} in text but $x^{2}$ in math";
        assert_snapshot!(fix_superscript_subscript(input), @r"x^2^ in text but $x^{2}$ in math");

        // Mixed: subscripts in text and math
        let input = r"H_{2}O in text but $H_{2}O$ in chemistry formula";
        assert_snapshot!(fix_superscript_subscript(input), @r"H~2~O in text but $H_{2}O$ in chemistry formula");

        // Multiple math sections
        let input = r"$a^{2}$ and x^{3} and $b^{4}$";
        assert_snapshot!(fix_superscript_subscript(input), @r"$a^{2}$ and x^3^ and $b^{4}$");

        // Empty braces
        let input = r"x^{} and y_{}";
        assert_snapshot!(fix_superscript_subscript(input), @r"x^^ and y~~");

        // Nested braces in content
        let input = r"x^{a{b}c}";
        assert_snapshot!(fix_superscript_subscript(input), @r"x^a{b}c^");

        // No braces after ^ or _
        let input = r"x^2 and y_i";
        assert_snapshot!(fix_superscript_subscript(input), @r"x^2 and y_i");

        // Just ^ or _ alone
        let input = r"^ and _";
        assert_snapshot!(fix_superscript_subscript(input), @r"^ and _");

        // Complex real-world example
        let input = r"The formula E^{tot}_{sys} = mc^{2} works, but $E = mc^{2}$ is in math mode";
        assert_snapshot!(fix_superscript_subscript(input), @r"The formula E^tot^~sys~ = mc^2^ works, but $E = mc^{2}$ is in math mode");

        // No replacements needed
        let input = r"Regular text with no special syntax";
        assert_snapshot!(fix_superscript_subscript(input), @r"Regular text with no special syntax");

        // Empty string
        let input = r"";
        assert_snapshot!(fix_superscript_subscript(input), @r"");

        // Multi-line input
        let input = "Line 1: x^{2}\nLine 2: $x^{2}$\nLine 3: y_{i}";
        assert_snapshot!(fix_superscript_subscript(input), @r"
        Line 1: x^2^
        Line 2: $x^{2}$
        Line 3: y~i~
        ");

        // Unclosed brace (edge case - collects to end)
        let input = r"x^{unclosed";
        assert_snapshot!(fix_superscript_subscript(input), @r"x^unclosed^");

        // Multiple dollars on same line
        let input = r"$a^{1}$ and $b^{2}$ and c^{3}";
        assert_snapshot!(fix_superscript_subscript(input), @r"$a^{1}$ and $b^{2}$ and c^3^");

        // Escaped dollar should not trigger math mode
        let input = r"I have \$10 and x^{2} here";
        assert_snapshot!(fix_superscript_subscript(input), @r"I have \$10 and x^2^ here");

        // Multiple escaped dollars
        let input = r"Cost is \$5 and profit^{max} is \$100";
        assert_snapshot!(fix_superscript_subscript(input), @r"Cost is \$5 and profit^max^ is \$100");

        // Escaped dollar followed by real math
        let input = r"Price: \$10, formula: $x^{2}$, result: y^{3}";
        assert_snapshot!(fix_superscript_subscript(input), @r"Price: \$10, formula: $x^{2}$, result: y^3^");

        // Escaped backslash before dollar (\\$ means literal backslash then math)
        let input = r"\\$x^{2}$";
        assert_snapshot!(fix_superscript_subscript(input), @r"\\$x^{2}$");

        // Other escaped characters shouldn't affect behavior
        let input = r"Test \_ and x^{2} and \_test";
        assert_snapshot!(fix_superscript_subscript(input), @r"Test \_ and x^2^ and \_test");
    }
}
