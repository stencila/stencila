use common::{
    eyre::Result,
    serde::{Deserialize, Serialize},
    serde_with::skip_serializing_none,
};
use format::Format;
use schema::{AuthorRole, AuthorRoleName};

use crate::Model;

/// The kind of generative model output
#[derive(Debug, Default, PartialEq, Deserialize, Serialize)]
#[serde(rename_all = "lowercase", crate = "common::serde")]
pub enum ModelOutputKind {
    /// Generated text in a text format
    #[default]
    Text,

    /// Generated content at a URL
    Url,
}

/// Output generated by a generative model for a task
#[skip_serializing_none]
#[derive(Debug, Default, Deserialize, Serialize)]
#[serde(default, deny_unknown_fields, crate = "common::serde")]
pub struct ModelOutput {
    /// The models that were involved in generating the output
    pub authors: Vec<AuthorRole>,

    /// The kind of output in the content
    ///
    /// Used to determine how to handle the `content` before
    /// decoding it into nodes.
    pub kind: ModelOutputKind,

    /// The format of the generated content
    ///
    /// Used by to decode the generated `content` into a set of
    /// Stencila Schema nodes.
    pub format: Format,

    /// The content generated by the assistant
    pub content: String,
}

impl ModelOutput {
    /// Create an empty `ModelOutput`
    ///
    /// Usually only used when the `--dry-run` flag is used.
    pub fn empty(model: &dyn Model) -> Result<Self> {
        Ok(Self {
            authors: vec![model.to_author_role(AuthorRoleName::Generator)],
            kind: ModelOutputKind::Text,
            format: Format::Unknown,
            content: (String::new()),
        })
    }

    /// Create a `ModelOutput` from text
    ///
    /// If the output format of the task in unknown (i.e. was not specified)
    /// then assumes it is Markdown.
    pub async fn from_text(model: &dyn Model, format: &Format, text: String) -> Result<Self> {
        Ok(Self {
            authors: vec![model.to_author_role(AuthorRoleName::Generator)],
            kind: ModelOutputKind::Text,
            format: format.clone(),
            content: text,
        })
    }

    /// Create a `ModelOutput` from a URL with a specific media type
    pub async fn from_url(model: &dyn Model, media_type: &str, url: String) -> Result<Self> {
        let format = Format::from_media_type(media_type).unwrap_or(Format::Unknown);

        Ok(Self {
            authors: vec![model.to_author_role(AuthorRoleName::Generator)],
            kind: ModelOutputKind::Url,
            format,
            content: url,
        })
    }
}
