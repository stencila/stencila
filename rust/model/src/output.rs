use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

use stencila_format::Format;
use stencila_schema::{AuthorRole, AuthorRoleName, File};

use crate::Model;

/// The kind of generative model output
#[derive(Debug, Default, PartialEq, Deserialize, Serialize)]
pub enum ModelOutputKind {
    /// Generated text in a text format
    #[default]
    Text,

    /// Generated content at a URL
    Url,
}

/// Output generated by a generative model for a task
#[skip_serializing_none]
#[derive(Debug, Default, Deserialize, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct ModelOutput {
    /// The models that were involved in generating the output
    pub authors: Vec<AuthorRole>,

    /// The kind of output in the content
    ///
    /// Used to determine how to handle the `content` before
    /// decoding it into Stencila Schema nodes.
    pub kind: ModelOutputKind,

    /// The format of the generated content
    ///
    /// Used by to decode the generated `content` into a set of
    /// Stencila Schema nodes.
    pub format: Format,

    /// The generated content
    pub content: String,

    /// File attachments to the generated content (e.g. images)
    pub attachments: Vec<File>,
}

impl ModelOutput {
    /// Create an empty `ModelOutput`
    ///
    /// Usually only used when the `--dry-run` flag is used.
    pub fn empty(model: &dyn Model) -> Self {
        Self {
            authors: vec![model.to_author_role(AuthorRoleName::Generator)],
            kind: ModelOutputKind::Text,
            ..Default::default()
        }
    }

    /// Create a `ModelOutput` from text
    ///
    /// If the format is `None` (i.e. was not specified for the task)
    /// then it is assumed to be Markdown.
    pub fn from_text(model: &dyn Model, format: &Option<Format>, text: String) -> Self {
        Self {
            authors: vec![model.to_author_role(AuthorRoleName::Generator)],
            kind: ModelOutputKind::Text,
            format: format.clone().unwrap_or(Format::Markdown),
            content: text,
            ..Default::default()
        }
    }

    /// Create a `ModelOutput` from text with attachments
    pub fn from_text_with(
        model: &dyn Model,
        format: &Option<Format>,
        text: String,
        attachments: Vec<File>,
    ) -> Self {
        Self {
            attachments,
            ..Self::from_text(model, format, text)
        }
    }

    /// Create a `ModelOutput` from a URL
    ///
    /// If the format is `None` (i.e. was not specified for the task)
    /// then it guessed from the URL.
    pub fn from_url(model: &dyn Model, format: &Option<Format>, url: String) -> Self {
        Self {
            authors: vec![model.to_author_role(AuthorRoleName::Generator)],
            kind: ModelOutputKind::Url,
            format: format.clone().unwrap_or_else(|| Format::from_url(&url)),
            content: url,
            ..Default::default()
        }
    }
}
