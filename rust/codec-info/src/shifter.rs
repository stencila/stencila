use std::{
    cell::{Ref, RefCell},
    time::Duration,
};

use similar::{Algorithm, Change, TextDiff};

/// Translates UTF8 character indices between two similar strings
///
/// Used when the content generated by a codec may differ from the source to
/// ensure that character indices in the generated content can be accurately
/// mapped to the line/column positions in the source.
pub struct Shifter<'source, 'generated> {
    /// The source content e.g. from a text editor or file
    source: &'source str,

    /// The generated content produced by a codec's `to_string` method
    generated: &'generated str,

    /// Whether this has been initialized. Allows avoid potentially costly
    /// string comparison
    initialized: RefCell<bool>,

    /// The [`DiffOp`]s representing the difference between the two strings
    /// and used to shift character indices between the two
    ops: RefCell<Option<Vec<Change<&'source str>>>>,
}

impl<'source, 'generated> Shifter<'source, 'generated>
where
    'source: 'generated,
    'generated: 'source,
{
    pub fn new(source: &'source str, generated: &'generated str) -> Self {
        Self {
            source,
            generated,
            initialized: RefCell::new(false),
            ops: RefCell::new(None),
        }
    }

    /// Get the [`DiffOps`], generating them just-in-time, if there is a difference
    /// between `source` and `generated`
    fn changes(&self) -> Ref<'_, Option<Vec<Change<&'source str>>>> {
        if *self.initialized.borrow() {
            return self.ops.borrow();
        }

        if self.generated == self.source {
            self.ops.replace(None);
        } else {
            let ops = TextDiff::configure()
                .algorithm(Algorithm::Myers)
                .timeout(Duration::from_secs(1))
                .diff_chars(self.generated, self.source)
                .iter_all_changes()
                .collect();
            self.ops.replace(Some(ops));
        }

        self.ops.borrow()
    }

    /// Translate a character index in `generated` to an index in `source`
    pub fn generated_to_source(&self, index: usize) -> usize {
        let changes = self.changes();
        let Some(changes) = changes.as_ref() else {
            return index.min(self.source.chars().count() - 1);
        };

        let mut current_new_index = 0usize;
        for change in changes {
            if let Some(old_index) = change.old_index() {
                if let Some(new_index) = change.new_index() {
                    current_new_index = new_index;
                }
                if old_index == index {
                    return current_new_index;
                }
            }
        }

        current_new_index.min(self.source.chars().count() - 1)
    }

    /// Translate a character index in `source` to an index in `generated`
    pub fn source_to_generated(&self, index: usize) -> usize {
        let changes = self.changes();
        let Some(changes) = changes.as_ref() else {
            return index.min(self.generated.chars().count() - 1);
        };

        let mut current_old_index = 0usize;
        for change in changes {
            if let Some(new_index) = change.new_index() {
                if let Some(old_index) = change.old_index() {
                    current_old_index = old_index;
                }
                if new_index == index {
                    return current_old_index;
                }
            }
        }

        current_old_index.min(self.generated.chars().count() - 1)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn equal() {
        let source = "abc";
        let generated = "abc";
        let shifter = Shifter::new(source, generated);

        assert_eq!(shifter.generated_to_source(0), 0);
        assert_eq!(shifter.generated_to_source(1), 1);
        assert_eq!(shifter.generated_to_source(2), 2);
        assert_eq!(shifter.generated_to_source(3), 2);

        assert_eq!(shifter.source_to_generated(0), 0);
        assert_eq!(shifter.source_to_generated(1), 1);
        assert_eq!(shifter.source_to_generated(2), 2);
        assert_eq!(shifter.source_to_generated(3), 2);
    }

    #[test]
    fn source_longer() {
        // Insertions within
        let source = "a  b c";
        let generated = "abc";
        let shifter = Shifter::new(source, generated);

        assert_eq!(shifter.generated_to_source(0), 0);
        assert_eq!(shifter.generated_to_source(1), 3);
        assert_eq!(shifter.generated_to_source(2), 5);
        assert_eq!(shifter.generated_to_source(3), 5);

        assert_eq!(shifter.source_to_generated(0), 0);
        assert_eq!(shifter.source_to_generated(1), 0);
        assert_eq!(shifter.source_to_generated(2), 0);
        assert_eq!(shifter.source_to_generated(3), 1);
        assert_eq!(shifter.source_to_generated(4), 1);
        assert_eq!(shifter.source_to_generated(5), 2);
        assert_eq!(shifter.source_to_generated(6), 2);

        // Insertions at ends and within
        let source = " a b  c ";
        let generated = "abc";
        let shifter = Shifter::new(source, generated);

        assert_eq!(shifter.generated_to_source(0), 1);
        assert_eq!(shifter.generated_to_source(1), 3);
        assert_eq!(shifter.generated_to_source(2), 6);
        assert_eq!(shifter.generated_to_source(3), 6);

        assert_eq!(shifter.source_to_generated(0), 0);
        assert_eq!(shifter.source_to_generated(1), 0);
        assert_eq!(shifter.source_to_generated(2), 0);
        assert_eq!(shifter.source_to_generated(3), 1);
        assert_eq!(shifter.source_to_generated(4), 1);
        assert_eq!(shifter.source_to_generated(5), 1);
        assert_eq!(shifter.source_to_generated(6), 2);
        assert_eq!(shifter.source_to_generated(7), 2);
        assert_eq!(shifter.source_to_generated(8), 2);
    }

    #[test]
    fn source_shorter() {
        // Insertions within
        let source = "abc";
        let generated = "a  b c";
        let shifter = Shifter::new(source, generated);

        assert_eq!(shifter.generated_to_source(0), 0);
        assert_eq!(shifter.generated_to_source(1), 0);
        assert_eq!(shifter.generated_to_source(2), 0);
        assert_eq!(shifter.generated_to_source(3), 1);
        assert_eq!(shifter.generated_to_source(4), 1);
        assert_eq!(shifter.generated_to_source(5), 2);
        assert_eq!(shifter.generated_to_source(6), 2);

        assert_eq!(shifter.source_to_generated(0), 0);
        assert_eq!(shifter.source_to_generated(1), 3);
        assert_eq!(shifter.source_to_generated(2), 5);
        assert_eq!(shifter.source_to_generated(3), 5);

        // Insertions at ends and within
        let source = "abc";
        let generated = " a b  c ";
        let shifter = Shifter::new(source, generated);

        assert_eq!(shifter.generated_to_source(0), 0);
        assert_eq!(shifter.generated_to_source(1), 0);
        assert_eq!(shifter.generated_to_source(2), 0);
        assert_eq!(shifter.generated_to_source(3), 1);
        assert_eq!(shifter.generated_to_source(4), 1);
        assert_eq!(shifter.generated_to_source(5), 1);
        assert_eq!(shifter.generated_to_source(6), 2);
        assert_eq!(shifter.generated_to_source(7), 2);
        assert_eq!(shifter.generated_to_source(8), 2);

        assert_eq!(shifter.source_to_generated(0), 1);
        assert_eq!(shifter.source_to_generated(1), 3);
        assert_eq!(shifter.source_to_generated(2), 6);
        assert_eq!(shifter.source_to_generated(3), 6);
    }
}
