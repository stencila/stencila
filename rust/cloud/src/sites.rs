//! Stencila Sites API client
//!
//! Functions for interacting with Stencila Sites via the Cloud API.

use std::io::Write;
use std::path::Path;

use chrono::DateTime;
use eyre::{Result, bail, eyre};
use flate2::{Compression, write::GzEncoder};
use reqwest::Client;
use reqwest::header::LAST_MODIFIED;
use serde::{Deserialize, Serialize};
use tokio::fs::{read, remove_file};
use url::Url;

use stencila_dirs::closest_site_file;

use crate::{api_token, base_url};

/// A route mapping or redirect rule
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Route {
    /// URL path (must start with `/`)
    pub path: String,

    /// File to serve at this path (relative to project root)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file: Option<String>,

    /// Redirect destination (relative or absolute URL)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redirect: Option<String>,

    /// HTTP status code for redirect (default 302)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<u16>,
}

/// Configuration for a Stencila Site
///
/// This is stored in `.stencila/site.yaml` in the project directory.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SiteConfig {
    // Unique site identifier
    ///
    /// Generated by Stencila Cloud when the site is created.
    pub id: String,

    /// Optional route overrides
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<Route>>,
}

impl SiteConfig {
    pub fn default_url(&self) -> String {
        return format!("https://{}.stencila.site", self.id);
    }

    /// Read the site configuration from `.stencila/site.yaml`
    pub async fn read(path: &Path) -> Result<SiteConfig> {
        let config_path = closest_site_file(path, false).await?;

        if !config_path.exists() {
            bail!("Site configuration not found at {}", config_path.display());
        }

        let content = tokio::fs::read_to_string(&config_path).await?;
        let config: SiteConfig = serde_yaml::from_str(&content)?;

        Ok(config)
    }

    /// Write the site configuration to `.stencila/site.yaml`
    async fn write(path: &Path, config: &SiteConfig) -> Result<()> {
        let config_path = closest_site_file(path, true).await?;

        let content = serde_yaml::to_string(config)?;
        tokio::fs::write(&config_path, content).await?;

        tracing::debug!("Site configuration written to {}", config_path.display());

        Ok(())
    }
}

/// Response from POST /sites
#[derive(Debug, Deserialize)]
struct CreateResponse {
    id: String,
}

/// Create a new site
#[tracing::instrument]
pub async fn create_site() -> Result<String> {
    let token = api_token()
        .ok_or_else(|| eyre!("No STENCILA_API_TOKEN environment variable or keychain entry found. Please set your API token."))?;

    tracing::debug!("Creating Stencila Site");
    let client = Client::new();
    let response = client
        .post(format!("{}/sites", base_url()))
        .bearer_auth(token)
        .send()
        .await?;

    if !response.status().is_success() {
        let status = response.status();
        let error_text = response.text().await.unwrap_or_default();
        bail!("Failed to create site ({status}): {error_text}");
    }

    let init_response: CreateResponse = response.json().await?;
    Ok(init_response.id)
}

/// Ensure a site configuration exists, creating it if necessary
///
/// Returns a tuple of (config, already_existed) where `already_existed` is true
/// if the site configuration was already present.
pub async fn ensure_site(path: &Path) -> Result<(SiteConfig, bool)> {
    let config_path = closest_site_file(path, false).await?;

    if config_path.exists() {
        // Configuration already exists, read it
        let config = SiteConfig::read(path).await?;
        Ok((config, true))
    } else {
        // Need to create new configuration
        tracing::info!("No site configuration found, creating new site");
        let id = create_site().await?;

        // Create config with defaults
        let config = SiteConfig { id, routes: None };

        // Write to disk
        SiteConfig::write(path, &config).await?;

        Ok((config, false))
    }
}

/// Upload a single file to the site
#[tracing::instrument]
pub async fn upload_file(site_id: &str, branch_slug: &str, path: &str, file: &Path) -> Result<()> {
    let token = api_token()
        .ok_or_else(|| eyre!("No STENCILA_API_TOKEN environment variable or keychain entry found. Please set your API token."))?;

    let content = read(file).await?;

    // Compress HTML for faster uploads, smaller storage, and faster downloads
    let (path, body) = if file.extension().map(|ext| ext == "html").unwrap_or(false) {
        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(&content)?;
        let compressed = encoder.finish()?;
        (format!("{path}.gz"), compressed)
    } else {
        (path.to_string(), content)
    };

    tracing::debug!("Uploading file to Stencila Site");
    let client = Client::new();
    let response = client
        .put(format!(
            "{}/sites/{site_id}/{branch_slug}/{path}",
            base_url()
        ))
        .bearer_auth(token)
        .body(body)
        .send()
        .await?;

    if !response.status().is_success() {
        let status = response.status();
        let error_text = response.text().await.unwrap_or_default();
        bail!("Failed to upload {path} ({status}): {error_text}");
    }

    Ok(())
}

/// Get the last modified time of a route on a Stencila Site
///
/// Makes a HEAD request to the URL (ensuring it has a trailing slash)
/// and returns the last-modified header as a Unix timestamp.
#[tracing::instrument]
pub async fn last_modified(url: &Url) -> Result<u64> {
    tracing::debug!("Fetching last-modified header from {url}");

    let client = Client::new();
    let response = client.head(url.to_string()).send().await?;

    if !response.status().is_success() {
        let status = response.status();
        bail!("Failed to fetch ({status}): {url}");
    }

    // Extract the last-modified header
    let headers = response.headers();
    let last_modified = headers
        .get(LAST_MODIFIED)
        .ok_or_else(|| eyre!("No last-modified header found for {url}"))?;

    // Convert header value to string
    let last_modified_str = last_modified
        .to_str()
        .map_err(|e| eyre!("Invalid last-modified header value: {e}"))?;

    // Parse RFC 2822 timestamp and convert to Unix timestamp
    let datetime = DateTime::parse_from_rfc2822(last_modified_str)
        .map_err(|e| eyre!("Failed to parse last-modified header '{last_modified_str}': {e}"))?;

    let timestamp = datetime.timestamp() as u64;

    tracing::debug!("Last modified timestamp for {url}: {timestamp}");
    Ok(timestamp)
}

/// Delete a site from Stencila Cloud and remove local configuration
///
/// This function will:
/// 1. Read the site configuration to get the site ID
/// 2. Call DELETE /sites/{id} to remove the site from Stencila Cloud
/// 3. Delete the local `.stencila/site.yaml` configuration file
///
/// Note: This function does not prompt for user confirmation. Callers should
/// handle confirmation before calling this function.
#[tracing::instrument]
pub async fn delete_site(path: &Path) -> Result<()> {
    // Read existing site config to get the site ID
    let config = SiteConfig::read(path).await?;

    // Get API token
    let token = api_token()
        .ok_or_else(|| eyre!("No STENCILA_API_TOKEN environment variable or keychain entry found. Please set your API token."))?;

    // Call DELETE /sites/{id}
    tracing::debug!("Deleting Stencila Site");
    let client = Client::new();
    let response = client
        .delete(format!("{}/sites/{}", base_url(), config.id))
        .bearer_auth(token)
        .send()
        .await?;

    if !response.status().is_success() {
        let status = response.status();
        let error_text = response.text().await.unwrap_or_default();
        bail!("Failed to delete site ({status}): {error_text}");
    }

    // Delete local config file
    let config_path = closest_site_file(path, false).await?;
    remove_file(&config_path).await?;

    tracing::debug!("Site deleted successfully");

    Ok(())
}
