use std::path::Path;

use eyre::{Result, bail, eyre};
use futures::future::try_join_all;
use serde::{Deserialize, Serialize};
use tempfile::TempDir;
use url::Url;

use stencila_cloud::sites::{StatusResponse, create_site, get_site_status, upload_file};
use stencila_codec::{Codec, EncodeOptions, stencila_schema::Node};
use stencila_codec_dom::DomCodec;
use stencila_dirs::{closest_site_file, closest_stencila_dir, workspace_dir};

/// Configuration for a Stencila Site
///
/// This is stored in `.stencila/site.yaml` in the project directory.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SiteConfig {
    /// TODO: Add a JSON schema URL for site.yaml and write it into the file

    /// Unique site identifier
    ///
    /// Generated by Stencila Cloud when the site is created.
    pub id: String,

    /// Optional route overrides
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<Route>>,
}

/// A route mapping or redirect rule
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Route {
    /// URL path (must start with `/`)
    pub path: String,

    /// File to serve at this path (relative to project root)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file: Option<String>,

    /// Redirect destination (relative or absolute URL)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redirect: Option<String>,

    /// HTTP status code for redirect (default 302)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<u16>,
}

/// File status comparison result
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FileStatusCheck {
    /// File is up to date (no need to push)
    UpToDate,
    /// File is behind (needs to be pushed)
    Behind,
    /// File doesn't exist on site (needs to be pushed)
    NotFound,
}

/// Read the site configuration from `.stencila/site.yaml`
pub async fn read_site_config(path: &Path) -> Result<SiteConfig> {
    let config_path = closest_site_file(path, false).await?;

    if !config_path.exists() {
        bail!("Site configuration not found at {}", config_path.display());
    }

    let content = tokio::fs::read_to_string(&config_path).await?;
    let config: SiteConfig = serde_yaml::from_str(&content)?;

    Ok(config)
}

/// Write the site configuration to `.stencila/site.yaml`
async fn write_site_config(path: &Path, config: &SiteConfig) -> Result<()> {
    let config_path = closest_site_file(path, true).await?;

    let content = serde_yaml::to_string(config)?;
    tokio::fs::write(&config_path, content).await?;

    tracing::info!("Site configuration written to {}", config_path.display());

    Ok(())
}

/// Ensure a site configuration exists, creating it if necessary
async fn ensure_site_config(path: &Path) -> Result<SiteConfig> {
    let config_path = closest_site_file(path, false).await?;

    if config_path.exists() {
        // Configuration already exists, read it
        read_site_config(path).await
    } else {
        // Need to create new configuration
        tracing::info!("No site configuration found, creating new site");
        let id = create_site().await?;

        // Create config with defaults
        let config = SiteConfig {
            id,
            routes: None,
        };

        // Write to disk
        write_site_config(path, &config).await?;

        Ok(config)
    }
}

/// Determine the URL route for a document file
///
/// First checks route overrides in site.yaml, then falls back to file-based routing.
///
/// # File-based routing rules:
/// - Extensions are stripped: `report.ipynb` → `/report/`
/// - Index files (`index.*`, `main.*`, `README.*`) → `/`
/// - Subdirectories are preserved: `docs/report.md` → `/docs/report/`
/// - All routes end with trailing slash
pub fn determine_route(
    file_path: &Path,
    workspace_dir: &Path,
    config: &SiteConfig,
) -> Result<String> {
    // Get path relative to project root
    let file_path = file_path.canonicalize()?;
    let rel_path = file_path.strip_prefix(workspace_dir).map_err(|_| {
        eyre!(
            "File path {} is not within project directory {}",
            file_path.display(),
            workspace_dir.display()
        )
    })?;

    // Normalize path separators to forward slashes for consistent comparison
    // (route overrides in site.yaml use forward slashes)
    let rel_path_str = rel_path.to_string_lossy().replace('\\', "/");

    // Check route overrides first
    if let Some(routes) = &config.routes {
        for route in routes {
            if let Some(file) = &route.file
                && rel_path_str == file.as_str()
            {
                return Ok(route.path.clone());
            }
        }
    }

    // Apply default file-based routing
    let file_stem = file_path
        .file_stem()
        .and_then(|s| s.to_str())
        .ok_or_else(|| eyre!("Invalid file path: {}", file_path.display()))?;

    // Check if this is an index file
    let is_index = matches!(file_stem, "index" | "main" | "README");

    // Build the route
    let route = if is_index {
        // Index files map to their directory
        if let Some(parent) = rel_path.parent() {
            if parent == Path::new("") {
                "/".to_string()
            } else {
                format!("/{}/", parent.to_string_lossy().replace('\\', "/"))
            }
        } else {
            "/".to_string()
        }
    } else {
        // Regular files: strip extension, add trailing slash
        if let Some(parent) = rel_path.parent() {
            if parent == Path::new("") {
                format!("/{}/", file_stem)
            } else {
                format!(
                    "/{}/{}/",
                    parent.to_string_lossy().replace('\\', "/"),
                    file_stem
                )
            }
        } else {
            format!("/{}/", file_stem)
        }
    };

    Ok(route)
}

/// Convert a URL route to a storage path for the HTML file
///
/// Routes always map to `index.html` files in their directory.
/// Examples:
/// - `/` → `index.html`
/// - `/report/` → `report/index.html`
/// - `/docs/analysis/` → `docs/analysis/index.html`
pub fn route_to_storage_path(route: &str) -> String {
    let trimmed = route.trim_start_matches('/').trim_end_matches('/');

    if trimmed.is_empty() {
        "index.html".to_string()
    } else {
        format!("{}/index.html", trimmed)
    }
}

/// Check the status of a file by comparing local and remote modification times
pub fn check_file_status(
    storage_path: &str,
    local_modified: u64,
    site_status: &Option<StatusResponse>,
) -> FileStatusCheck {
    match site_status {
        None => {
            // No site status available, assume file needs to be pushed
            FileStatusCheck::NotFound
        }
        Some(status) => {
            if let Some(remote_file) = status.files.get(storage_path) {
                // File exists on site, compare modification times
                if local_modified > remote_file.modified_at {
                    FileStatusCheck::Behind
                } else {
                    FileStatusCheck::UpToDate
                }
            } else {
                // File doesn't exist on site
                FileStatusCheck::NotFound
            }
        }
    }
}

/// Check if a document file should be pushed to a Stencila Site
///
/// This is a convenience function that combines all the steps needed to determine
/// if a file needs to be pushed: fetching site status, getting local file modification
/// time, determining the route, and comparing timestamps.
///
/// Returns `Ok(true)` if the file should be skipped (is up-to-date),
/// `Ok(false)` if it should be pushed, or `Err` if the status check failed.
pub async fn should_skip_push(
    doc_path: &Path,
    project_dir: &Path,
    config: &SiteConfig,
) -> Result<bool> {
    // Get site status from Cloud API
    let site_status = get_site_status(&config.id).await?;

    // Get local file modification time
    let metadata = std::fs::metadata(doc_path)?;
    let modified = metadata.modified()?;
    let local_modified = modified.duration_since(std::time::UNIX_EPOCH)?.as_secs();

    // Determine route and storage path for this file
    let route = determine_route(doc_path, project_dir, config)?;
    let storage_path = route_to_storage_path(&route);

    // Check file status
    let status = check_file_status(&storage_path, local_modified, &site_status);

    // Return true (skip push) only if file is up-to-date
    Ok(matches!(status, FileStatusCheck::UpToDate))
}

/// Push a document to a Stencila Site
///
/// If `url` is provided, updates the existing document at that site.
/// Otherwise, creates or updates a document in the configured site.
///
/// Returns the URL of the published document on the site.
pub async fn push(
    node: &Node,
    path: Option<&Path>,
    title: Option<&str>,
    url: Option<&Url>,
) -> Result<Url> {
    // Find the workspace root directory
    let start_path = if let Some(path) = path {
        path.to_path_buf()
    } else {
        std::env::current_dir()?
    };

    let stencila_dir = closest_stencila_dir(&start_path, true).await?;
    let workspace_dir = workspace_dir(&stencila_dir)?;

    // Ensure site configuration exists
    let config = ensure_site_config(&start_path).await?;
    let site_id = &config.id;

    // Build base URL for the site
    let base_url = if let Some(url) = url {
        // If URL provided, use its host as the base
        format!("{}://{}", url.scheme(), url.host_str().unwrap_or("unknown"))
    } else {
        // Default to the stencila.site subdomain
        format!("https://{site_id}.stencila.site")
    };

    // Create temporary directory for HTML and extracted and collected media
    let temp_dir = TempDir::new()?;
    let temp_html = temp_dir.path().join("temp.html");
    let media_dir = temp_dir.path().join("media");

    // Encode HTML
    DomCodec
        .to_path(
            node,
            &temp_html,
            Some(EncodeOptions {
                standalone: Some(true),
                base_url: Some(base_url.to_string()),
                from_path: path.map(|path| path.to_path_buf()),
                to_path: Some(temp_html.clone()),
                extract_media: Some(media_dir.clone()),
                collect_media: Some(media_dir.clone()),
                // TODO: Allow theme and view customization
                view: Some("static".into()),
                ..Default::default()
            }),
        )
        .await?;

    // Upload media files in parallel
    if media_dir.exists() {
        let mut entries = tokio::fs::read_dir(&media_dir).await?;
        let mut media_files = Vec::new();

        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file()
                && let Some(filename) = path.file_name().and_then(|n| n.to_str())
            {
                let storage_path = format!("media/{filename}");
                media_files.push((storage_path, path));
            }
        }

        if !media_files.is_empty() {
            let upload_futures = media_files
                .iter()
                .map(|(storage_path, path)| upload_file(site_id, storage_path, path));
            try_join_all(upload_futures).await?;
        }
    }

    // Determine route based on doc_path or fallback to title-based heuristic
    let route = if let Some(path) = path {
        determine_route(path, &workspace_dir, &config)?
    } else if let Some(title) = title {
        // Fallback: use a simple heuristic based on title
        let cleaned = title.trim_end_matches(|c: char| !c.is_alphanumeric());
        if cleaned.is_empty() {
            "/document/".to_string()
        } else {
            format!("/{}/", cleaned.to_lowercase().replace(' ', "-"))
        }
    } else {
        "/document/".to_string()
    };

    // Convert route to storage path
    let storage_path = route_to_storage_path(&route);

    // Upload HTML
    upload_file(site_id, &storage_path, &temp_html).await?;

    // Return the site URL with the route
    let site_url = format!("{base_url}{}", route.trim_end_matches('/'));
    Ok(Url::parse(&site_url)?)
}

/// Pull a document from a Stencila Site
///
/// **Note:** Pull is not supported for Stencila Sites. Sites are write-only remotes
/// since the source documents are maintained locally.
pub async fn pull(_url: &Url, _dest: &Path) -> Result<()> {
    bail!("Pull operation is not supported for Stencila Sites which are write-only remotes.")
}

/// Time that a Stencila Site was last modified as a Unix timestamp.
///
/// Queries the Cloud API for the last modification time of the site.
pub async fn modified_at(url: &Url) -> Result<u64> {
    // Extract site ID from URL
    let host = url
        .host_str()
        .ok_or_else(|| eyre!("Invalid site URL: no host"))?;

    // Expected format: {siteId}.stencila.site
    let site_id = host.strip_suffix(".stencila.site").ok_or_else(|| {
        eyre!("Invalid site URL: host should be in format {{siteId}}.stencila.site")
    })?;

    // Query the Cloud API for site status
    match get_site_status(site_id).await {
        Ok(Some(status)) => {
            // Find the most recent modification time across all files
            let max_modified = status
                .files
                .values()
                .map(|f| f.modified_at)
                .max()
                .unwrap_or(0);
            Ok(max_modified)
        }
        Ok(None) => {
            // Site doesn't have status yet
            Ok(0)
        }
        Err(_) => {
            // If the API call fails, return 0
            tracing::warn!("Could not fetch site status, returning 0 for modified_at");
            Ok(0)
        }
    }
}
