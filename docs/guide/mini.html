<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
  <main>
    <div id="data" data-format="html">
      <div class="content">
        <div data-title="">Mini</div>
        <p>Stencila has it's own language for reproducible, data-drive, research called <em>Mini</em>. An important aspect of reproducibility is readability. Mini aims to be as easy to read and understand as it is to write. Mini is meant to be only slightly more advanced that the expressions that your write in your calculator or into the cell of a spreadsheet</p>
        <h1>Types</h1>
        <p>Mini has a simple type system that is similar to most high level languages. Each type can be constructed using literals...</p>
        <table>
          <tr>
            <td>Type</td>
            <td>Example literal</td>
          </tr>
          <tr>
            <td>null</td>
            <td><code>null</code></td>
          </tr>
          <tr>
            <td>boolean</td>
            <td><code>true, false</code></td>
          </tr>
          <tr>
            <td>integer</td>
            <td><code>1, 2, 42</code></td>
          </tr>
          <tr>
            <td>float</td>
            <td><code>3.13</code></td>
          </tr>
          <tr>
            <td>array</td>
            <td><code>[1, 2, 3]</code></td>
          </tr>
          <tr>
            <td>object</td>
            <td><code>{ a: 1, b: '2'}</code></td>
          </tr>
          <tr>
            <td>my_custom_type</td>
            <td><code>{ type: 'my_custom_type', ...}</code></td>
          </tr>
        </table>
        <h1>Tabular data </h1>
        <p>Tabular data is an important part of data analysis...</p>
        <div data-cell="data = table({
species: {type: 'nominal', values: concat(repeat('setosa',50), repeat('versicolor',50), repeat('virginica',50))},
sepal_length: {values: [5.1,4.9,4.7,4.6,5,5.4,4.6,5,4.4,4.9,5.4,4.8,4.8,4.3,5.8,5.7,5.4,5.1,5.7,5.1,5.4,5.1,4.6,5.1,4.8,5,5,5.2,5.2,4.7,4.8,5.4,5.2,5.5,4.9,5,5.5,4.9,4.4,5.1,5,4.5,4.4,5,5.1,4.8,5.1,4.6,5.3,5,7,6.4,6.9,5.5,6.5,5.7,6.3,4.9,6.6,5.2,5,5.9,6,6.1,5.6,6.7,5.6,5.8,6.2,5.6,5.9,6.1,6.3,6.1,6.4,6.6,6.8,6.7,6,5.7,5.5,5.5,5.8,6,5.4,6,6.7,6.3,5.6,5.5,5.5,6.1,5.8,5,5.6,5.7,5.7,6.2,5.1,5.7,6.3,5.8,7.1,6.3,6.5,7.6,4.9,7.3,6.7,7.2,6.5,6.4,6.8,5.7,5.8,6.4,6.5,7.7,7.7,6,6.9,5.6,7.7,6.3,6.7,7.2,6.2,6.1,6.4,7.2,7.4,7.9,6.4,6.3,6.1,7.7,6.3,6.4,6,6.9,6.7,6.9,5.8,6.8,6.7,6.7,6.3,6.5,6.2,5.9]},
sepal_width: {values: [3.5,3,3.2,3.1,3.6,3.9,3.4,3.4,2.9,3.1,3.7,3.4,3,3,4,4.4,3.9,3.5,3.8,3.8,3.4,3.7,3.6,3.3,3.4,3,3.4,3.5,3.4,3.2,3.1,3.4,4.1,4.2,3.1,3.2,3.5,3.6,3,3.4,3.5,2.3,3.2,3.5,3.8,3,3.8,3.2,3.7,3.3,3.2,3.2,3.1,2.3,2.8,2.8,3.3,2.4,2.9,2.7,2,3,2.2,2.9,2.9,3.1,3,2.7,2.2,2.5,3.2,2.8,2.5,2.8,2.9,3,2.8,3,2.9,2.6,2.4,2.4,2.7,2.7,3,3.4,3.1,2.3,3,2.5,2.6,3,2.6,2.3,2.7,3,2.9,2.9,2.5,2.8,3.3,2.7,3,2.9,3,3,2.5,2.9,2.5,3.6,3.2,2.7,3,2.5,2.8,3.2,3,3.8,2.6,2.2,3.2,2.8,2.8,2.7,3.3,3.2,2.8,3,2.8,3,2.8,3.8,2.8,2.8,2.6,3,3.4,3.1,3,3.1,3.1,3.1,2.7,3.2,3.3,3,2.5,3,3.4,3]}
})">
          <pre data-output="">[object Object]</pre>
        </div>
        <h1>Plotting</h1>
        <p>The <code>plot</code> function takes tabular data, ....</p>
        <div data-cell="plot(data, 'points', 'sepal_length', 'sepal_width')">
          <pre data-output="">[object Object]</pre>
        </div>
        <p>Can set plot options of the Vega-Lite spec....</p>
        <div data-cell="points(data, 'sepal_length', 'sepal_width', color='species', options={
  encoding:{
    color:{
      legend:{title:'Species name'}
    }
  }
})">
          <pre data-output="">[object Object]</pre>
        </div>
        <p>Or use convieience functions like <code>title</code> to set options</p>
        <div data-cell="titles(points(data, 'sepal_length', 'sepal_width', color='species'), color='Species name')">
          <pre data-output="">[object Object]</pre>
        </div>
        <h2>Using other languages</h2>
        <p>An important feature of Mini is it's ability to interoperate with other languages. Mini can act as a &amp;quot;glue&amp;quot; language - for those times when you need to combine the strengths of several languages. For example, you might want to extract some data from a database using Structured Query Language (SQL), then perform a specialised statistical analysis on the data using R, then visualise the results using Mini's built in plotting functions.</p>
        <p>Mini makes this possible through alternative execution &amp;quot;contexts&amp;quot;. Each context knows how to convert values to and from the Mini value types and how to execute snippets of code in the context's native language. Currently, only two execution contexts are supported: the <code>JsContext</code> (for executing Javascript code in a browser or desktop window) and the <code>NodeContext</code> (for executing Javascript code within Node.js). The <code>RContext</code> and <code>PythonContexts</code> are planned for the 0.26 release with more language contexts following soon.</p>
        <p>There are two special functions in Mini for executing code in other languages: <code>call</code> and <code>run</code>. </p>
        <h3>The <code>call</code> function</h3>
        <p>The <code>call</code> function executes code within a function scope. That means that any variables that you declare within that function are local to the function and won't leak into the context's global scope. So, when you type <code>call()</code> into a cell, your effectively saying to Mini &amp;quot;take this code, make it into a function, execute the function, and give me back the value. Here's an example of a simple <code>call</code> to some Javascript,</p>
        <div data-cell="call()" data-language="js">
          <pre data-source="">let names = ['Hiphop', 'opotamus', ' v ', 'Rhyme', 'noceros']
return names.join('')</pre>
          <pre data-output="">Hiphopopotamus v Rhymenoceros</pre>
        </div>
        <p>Notice that because we ended the JavaScript code, with a <code>return</code> statement that the cell has an output. When you <code>call()</code> some JavaScript <code>code</code> it's like executing <code>(function(){code})()</code>. The same is true for other external languages, it's just that the syntax differs.</p>
        <p>Just like with other Mini cells, you can assign the output of a <code>call()</code> to a document variable,</p>
        <div data-cell="javascript_pi = call()" data-language="js">
          <pre data-source="">return Math.PI</pre>
          <pre data-output="">3.141592653589793</pre>
        </div>
        <p>A call to another language is not very useful unless you provide it with some data. This is where Mini's &amp;quot;glueing&amp;quot; comes in. Let's create an array in Mini,</p>
        <div data-cell="fruits = ['apple', 'pear', 'kiwi']">
          <pre data-output="">apple,pear,kiwi</pre>
        </div>
        <p>and then use Javascript to join it together,</p>
        <div data-cell="call(fruits)" data-language="js">
          <pre data-source="">return 'My favourite fruits: ' + fruits.map((fruit,index) =&gt; {
    return `${index + 1}. ${fruit}`
}).join(', ')</pre>
          <pre data-output="">My favourite fruits: 1. apple, 2. pear, 3. kiwi</pre>
        </div>
        <p>The nice thing about this is that Mini's dependency analysis still works, so you can change the fruits array and the output above will change - try it! </p>
        <p>Notice that our Javascript function got supplied an argument called <code>fruits</code> - which is the same array of strings as in our documentent variable called <code>fruits</code>. You can also provide named arguments to <code>call,</code></p>
        <div data-cell="call(my_favourite_fruits = fruits, index = 2)" data-language="js">
          <pre data-source="">return my_favourite_fruits[index]</pre>
          <pre data-output="">kiwi</pre>
        </div>
        <p>Here's an example, that puts this all together with an input, a Javascript call cell and an output to display the result...</p>
        <p>The area of a circle can be calculated by <span data-math="asciimath">a = pi r^2</span>. So, if the radius of a circle is <input type="range" name="radius" min="0" max="100" step="1" value="36"></input> m, then it's area is: <span data-cell="area">10</span> m<sup>2</sup>.</p>
        <div data-cell="area = call(r=radius)" data-language="js">
          <pre data-source="">return Math.PI*Math.pow(radius, 2)</pre>
          <pre data-output=""></pre>
        </div>
        <h3>The <code>run</code> function</h3>
        <p></p>
      </div>
    </div>
  </main>
</body>

</html>